# [\#4721 Issue](https://github.com/ethereum/solidity/issues/4721) `closed`: Referenced functions can be always determined at compile time in Solidity?

#### <img src="https://avatars.githubusercontent.com/u/13723704?v=4" width="50">[SunBeomSo](https://github.com/SunBeomSo) opened issue at [2018-08-07 05:02](https://github.com/ethereum/solidity/issues/4721):

**A question in one sentence:**
Regarding function call expressions in Solidity, can we always statically determine which functions will be invoked at compile time(not at runtime)?

**Example Code:**

```
contract A {
    uint256 public n;
    function set () public {
        n = 50;
    }
}

contract B is A {
    function set () public {
        n = 40;
    }
}

contract C is A,B {
    function test (uint n) public {
        A a;
        if (n==1){
            a = new A();
        } 
        else{
            a = B(new B());
        }
        a.set(); // member of A or B? The Compiler says that the function is a member of A. 
    }
}
```
Considering features in Java programs, _**it seems that, at compile time, we cannot determine**_ whether the “set” function, invoked in the "test" function in contract C, is a member function of A contract or B contract (because the variable "a" will be instantiated as a different type of contract, according to the argument "n" of the function "test").

However, inspecting AST generated by a Solidity compiler (the value of the "referencedDeclaration" attribute with an option solc --ast-compact-json), the invoked “set” function is referred as a member of A contract, not B contract. I am not sure whether it is an intentional feature of Solidity.

In addition, in the "referencedDeclaration" attribute of the AST in JSON, the corresponding value exists as an integer type, not a list type, which seems to imply that the answer for my question may be "yes".

#### <img src="https://avatars.githubusercontent.com/u/9073706?v=4" width="50">[chriseth](https://github.com/chriseth) commented at [2018-08-07 05:02](https://github.com/ethereum/solidity/issues/4721#issuecomment-411025241):

`referencedDeclaration` is the declaration the compiler will use to call `set` as far as type checking and so on is concerned. This does not mean that it will be the function that is actually executed in the end, but it just means that `a` is of type `A` and so `a.set` is `A.set`.

In general, it is impossible to determine which function will be called, even for internal functions, because of function pointers.

#### <img src="https://avatars.githubusercontent.com/u/13723704?v=4" width="50">[SunBeomSo](https://github.com/SunBeomSo) commented at [2018-08-07 05:02](https://github.com/ethereum/solidity/issues/4721#issuecomment-412896894):

@chriseth Thanks for the response!

#### <img src="https://avatars.githubusercontent.com/u/9073706?v=4" width="50">[chriseth](https://github.com/chriseth) commented at [2018-08-07 05:02](https://github.com/ethereum/solidity/issues/4721#issuecomment-412900815):

So, can this be closed?

#### <img src="https://avatars.githubusercontent.com/u/13723704?v=4" width="50">[SunBeomSo](https://github.com/SunBeomSo) commented at [2018-08-07 05:02](https://github.com/ethereum/solidity/issues/4721#issuecomment-412907571):

@chriseth Can I have just one more question? From Solidity compiler, is there a way to get "conservative" information about which function definitions would be referenced?
(e.g., mayreferencedDeclaration: [a,b] --- if both "a" and "b" can referenced at runtime)
I have been working on Solidity verification and I am not sure if I have to implement my own analysis to get that information.

#### <img src="https://avatars.githubusercontent.com/u/9073706?v=4" width="50">[chriseth](https://github.com/chriseth) commented at [2018-08-07 05:02](https://github.com/ethereum/solidity/issues/4721#issuecomment-412913884):

@SunBeomSo this only works for overloading but not overriding. The reason is that the ast-json for contract C is exported assuming that C is the contract that is being deployed. If you use C as a base contract in D, then the functions referenced from C will change and that information might not yet be available when C is compiled.

If you know a solution to this, I would gladly add it to the compiler.

#### <img src="https://avatars.githubusercontent.com/u/13723704?v=4" width="50">[SunBeomSo](https://github.com/SunBeomSo) commented at [2018-08-07 05:02](https://github.com/ethereum/solidity/issues/4721#issuecomment-412920647):

@chriseth Sorry but can you give example code? I did not understand what the problematic situation is.

#### <img src="https://avatars.githubusercontent.com/u/9073706?v=4" width="50">[chriseth](https://github.com/chriseth) commented at [2018-08-07 05:02](https://github.com/ethereum/solidity/issues/4721#issuecomment-412940425):

In your example code, inside `A`, when you call `set()`, it will always point to the function `set` inside `A`. But if you inherit from `A` and override the function, the call from `A` will actually call the other function.

```
contract A { function set() {..} function f() { set(); } }
contract B is A { function set() { ... } }
```

If you call `(new B()).f()`, then `A::f` will call `B::set`.

#### <img src="https://avatars.githubusercontent.com/u/13723704?v=4" width="50">[SunBeomSo](https://github.com/SunBeomSo) commented at [2018-08-07 05:02](https://github.com/ethereum/solidity/issues/4721#issuecomment-413063164):

@chriseth   Thanks. That's an interesting case. You can close this issue, and I will refer this issue when I get to know a solution.


-------------------------------------------------------------------------------



[Export of Github issue for [ethereum/solidity](https://github.com/ethereum/solidity). Generated on 2022.05.23 at 03:51:38.]
