# [\#6015 Issue](https://github.com/ethereum/solidity/issues/6015) `open`: Optimisation rule for replacing div/mul with shr/shl
**Labels**: `enhancement`, `optimizer`


#### <img src="https://avatars.githubusercontent.com/u/20340?v=4" width="50">[axic](https://github.com/axic) opened issue at [2019-02-14 23:34](https://github.com/ethereum/solidity/issues/6015):

With Constantinople we have SHL/SHR opcodes and the codegen already utilises that if shift operators are being used. There is also an optimisation rule to replace shifts of constants with a constant.

However due to a missing feature (passing EVM version) to simplification rules we do not have any to transform div/mul.

The rule should be as follows:
- `div(x, y)` where y is a power of 2 can be transformed to `shr(x, log2(y))` where `log2(y)` should be precomputed of course
- same with `mul(x, y)` -> `shl(x, log2(y))`

This should help to optimise code where shifts are used in inline assembly. One good example is ENS' [solsha1](https://github.com/ensdomains/solsha1).

@ekpyron @chriseth any ideas how to introduce EVM version dependent rules into the simplificationrules?

#### <img src="https://avatars.githubusercontent.com/u/1347491?v=4" width="50">[ekpyron](https://github.com/ekpyron) commented at [2019-02-14 23:34](https://github.com/ethereum/solidity/issues/6015#issuecomment-464058189):

Might it make sense to just always add these rules and always translate to shifts and only to replace all shifts back to ``div`` and ``mul`` during EVM bytecode generation (at that stage we need to know the EVM version anyways)?

Also: we probably need more rules than that for the shifts? Like associativity rules and merging sequences of shifts when possible? What about mixing mul/div and shl/shr and so on?

#### <img src="https://avatars.githubusercontent.com/u/20340?v=4" width="50">[axic](https://github.com/axic) commented at [2019-02-14 23:34](https://github.com/ethereum/solidity/issues/6015#issuecomment-464062216):

>  only to replace all shifts back to `div` and `mul` during EVM bytecode generation

Well currently these rules are applied *after* code generation.

> Like associativity rules and merging sequences of shifts when possible?

That could be useful. Could also be added right now without any risk as long as the rules depend on `shl`/`shr` being present as that suggest the code was already compiled for constantinople.

> What about mixing mul/div and shl/shr and so on?

I think this also could be added without risk as long as it depends on `shl`/`shr` being present in the first place.

#### <img src="https://avatars.githubusercontent.com/u/1347491?v=4" width="50">[ekpyron](https://github.com/ekpyron) commented at [2019-02-14 23:34](https://github.com/ethereum/solidity/issues/6015#issuecomment-464065047):

Yes, I haven't thought that through - but the rules are not only applied after code generation, but also in the yul simplifier before code generation...
But anyways: we could still always convert to shifts and in the case of old evm versions just have another pass after running the rules that will replace all shifts with mul/div again. This would allow us to simplify code generation for shifts (we could always emit shift instructions, if they are automatically replaced at the very end for old evm versions).

#### <img src="https://avatars.githubusercontent.com/u/20340?v=4" width="50">[axic](https://github.com/axic) commented at [2019-02-14 23:34](https://github.com/ethereum/solidity/issues/6015#issuecomment-464065495):

> This would allow us to simplify code generation for shifts (we could always emit shift instructions, if they are automatically replaced at the very end for old evm versions).

I think that might be a good idea. I think the rule list should be run after applying that "final" pass though.

#### <img src="https://avatars.githubusercontent.com/u/1347491?v=4" width="50">[ekpyron](https://github.com/ekpyron) commented at [2019-02-14 23:34](https://github.com/ethereum/solidity/issues/6015#issuecomment-464065700):

More generally it might be possible to always generate byte code for the most recent evm version first and optimize that and have a dedicated pass afterwards that "downgrades" the generated byte code to be compatible with older EVM versions - we'd need to think about whether that's possible, though (e.g. for things like staticcall, etc.).

#### <img src="https://avatars.githubusercontent.com/u/1347491?v=4" width="50">[ekpyron](https://github.com/ekpyron) commented at [2019-02-14 23:34](https://github.com/ethereum/solidity/issues/6015#issuecomment-464065955):

> > This would allow us to simplify code generation for shifts (we could always emit shift instructions, if they are automatically replaced at the very end for old evm versions).
> 
> I think that might be a good idea. I think the rule list should be run after applying that "final" pass though.

I'm not sure - why would we want to run this pass before optimization and not after? Ideally the result would be the same and we wouldn't need to let the rules depend on the evm version.

#### <img src="https://avatars.githubusercontent.com/u/20340?v=4" width="50">[axic](https://github.com/axic) commented at [2019-02-14 23:34](https://github.com/ethereum/solidity/issues/6015#issuecomment-464066751):

After you have replaced a shift with multiplication for example it might be apparent that you can combine two multiplications (`mul shl` -> `mul mul` -> `mul`).

Also keep in mind that different "evm versions" (more like hard forks) can command different gas costs for instructions and this influences certain optimisation steps (for example the constant optimiser).

#### <img src="https://avatars.githubusercontent.com/u/1347491?v=4" width="50">[ekpyron](https://github.com/ekpyron) commented at [2019-02-14 23:34](https://github.com/ethereum/solidity/issues/6015#issuecomment-464067889):

The question is: might the ``mul shl``->``mul mul``->``mul`` simplification be worth it, even if we have shifts available? That probably depends on the values :-)...

#### <img src="https://avatars.githubusercontent.com/u/20340?v=4" width="50">[axic](https://github.com/axic) commented at [2019-02-14 23:34](https://github.com/ethereum/solidity/issues/6015#issuecomment-464068264):

This is the exact question I was contemplating, but if I remember correctly the rule list does a gas calculation after an iteration to see if it is worth it. So potentially could do the mul rule even if shift is used ðŸ˜‰

#### <img src="https://avatars.githubusercontent.com/u/1347491?v=4" width="50">[ekpyron](https://github.com/ekpyron) commented at [2019-02-14 23:34](https://github.com/ethereum/solidity/issues/6015#issuecomment-464071416):

In any case, in the meantime I tend to agree that we might want to pass the EVMVersion to the rule list: even if we replace all shifts before applying the rules, we still need to disable the ``mul->shl`` rule.
The question is: what about the yul simplifier? It should probably be EVM-version-agnostic (resp. bytecode agnostic in general) - but does that mean it should do ``mul->shl`` or ``shl->mul`` :-)?

#### <img src="https://avatars.githubusercontent.com/u/1347491?v=4" width="50">[ekpyron](https://github.com/ekpyron) commented at [2019-02-14 23:34](https://github.com/ethereum/solidity/issues/6015#issuecomment-464079869):

> This is the exact question I was contemplating, but if I remember correctly the rule list does a gas calculation after an iteration to see if it is worth it. So potentially could do the mul rule even if shift is used wink

Does it? Check the gas benefit I mean? I'm not too familiar with the bytecode optimizer code, but I wouldn't see where it'd do that - and it'd be tricky anyways - ``shl->mul`` would always be bad in one iteration, but might be worth it after another step doing ``mul mul->mul``... the only way to always be optimal here would probably be backtracking, wouldn't it?

If we did check the gas costs for every iteration and did backtracking, then we could just set the gas costs for shl/shr to infinite where it isn't supported and that should do it :-).

#### <img src="https://avatars.githubusercontent.com/u/9073706?v=4" width="50">[chriseth](https://github.com/chriseth) commented at [2019-02-14 23:34](https://github.com/ethereum/solidity/issues/6015#issuecomment-464726515):

The gas calculation just counts instructions, not their cost, if I remember correctly.

#### <img src="https://avatars.githubusercontent.com/u/20340?v=4" width="50">[axic](https://github.com/axic) commented at [2019-02-14 23:34](https://github.com/ethereum/solidity/issues/6015#issuecomment-474672720):

This can be easily implemented after #6318.

#### <img src="https://avatars.githubusercontent.com/u/20340?v=4" width="50">[axic](https://github.com/axic) commented at [2019-02-14 23:34](https://github.com/ethereum/solidity/issues/6015#issuecomment-665218824):

Hm, I actually had some local code implementing this. Will push.

#### <img src="https://avatars.githubusercontent.com/u/13174375?u=52d702cb6bec53b561afa293cf9cd53ef7a63924&v=4" width="50">[hrkrshnn](https://github.com/hrkrshnn) commented at [2019-02-14 23:34](https://github.com/ethereum/solidity/issues/6015#issuecomment-701992564):

@axic Do you have a branch implementing this?

#### <img src="https://avatars.githubusercontent.com/u/20340?v=4" width="50">[axic](https://github.com/axic) commented at [2019-02-14 23:34](https://github.com/ethereum/solidity/issues/6015#issuecomment-796640444):

https://github.com/ethereum/solidity/commit/35fe5cde06ebaec4abe2e57e366495d2c8f25b21, but now it can be implemented using the `feasible` feature with less rules (see https://github.com/ethereum/solidity/issues/6015#issuecomment-474672720)


-------------------------------------------------------------------------------



[Export of Github issue for [ethereum/solidity](https://github.com/ethereum/solidity). Generated on 2022.05.23 at 03:51:38.]
