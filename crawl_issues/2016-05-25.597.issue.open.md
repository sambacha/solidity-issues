# [\#597 Issue](https://github.com/ethereum/solidity/issues/597) `open`: Allow specifying storage locations
**Labels**: `language design :rage4:`, `must have eventually`


#### <img src="https://avatars.githubusercontent.com/u/824194?v=4" width="50">[pipermerriam](https://github.com/pipermerriam) opened issue at [2016-05-25 05:02](https://github.com/ethereum/solidity/issues/597):

Inline assembly has now made fully up upgradable contracts possible.  One of the main hangups with this is that the storage locations have to stay the same across upgrades.  Would it be possible to introduce support for specifying the storage locations for storage variables?


#### <img src="https://avatars.githubusercontent.com/u/7756785?u=2893ea91743ac89ee3846d1f5c7209720e834129&v=4" width="50">[VoR0220](https://github.com/VoR0220) commented at [2016-05-25 06:55](https://github.com/ethereum/solidity/issues/597#issuecomment-221488744):

not so!

#### <img src="https://avatars.githubusercontent.com/u/7756785?u=2893ea91743ac89ee3846d1f5c7209720e834129&v=4" width="50">[VoR0220](https://github.com/VoR0220) commented at [2016-05-25 06:56](https://github.com/ethereum/solidity/issues/597#issuecomment-221488973):

See Nick Johnson's Library on upgradeability :)

https://gist.github.com/Arachnid/4ca9da48d51e23e5cfe0f0e14dd6318f#file-upgradeable-sol

#### <img src="https://avatars.githubusercontent.com/u/9073706?v=4" width="50">[chriseth](https://github.com/chriseth) commented at [2016-05-25 07:54](https://github.com/ethereum/solidity/issues/597#issuecomment-221499635):

Especially with contract upgrades in mind, wouldn't it be better to copy the storage layout and "disable" unused state variables by e.g. prefixing them? Otherwise I don't see how you would practically verify that the storage layout is consistent between upgrades.

#### <img src="https://avatars.githubusercontent.com/u/824194?v=4" width="50">[pipermerriam](https://github.com/pipermerriam) commented at [2016-05-25 12:42](https://github.com/ethereum/solidity/issues/597#issuecomment-221563568):

Is there documentation on how storage layout is determined?

On Wed, May 25, 2016, 1:54 AM chriseth notifications@github.com wrote:

> Especially with contract upgrades in mind, wouldn't it be better to copy
> the storage layout and "disable" unused state variables by e.g. prefixing
> them? Otherwise I don't see how you would practically verify that the
> storage layout is consistent between upgrades.
> 
> ‚Äî
> You are receiving this because you authored the thread.
> Reply to this email directly or view it on GitHub
> https://github.com/ethereum/solidity/issues/597#issuecomment-221499635

#### <img src="https://avatars.githubusercontent.com/u/9073706?v=4" width="50">[chriseth](https://github.com/chriseth) commented at [2016-05-25 14:09](https://github.com/ethereum/solidity/issues/597#issuecomment-221587759):

http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage

#### <img src="https://avatars.githubusercontent.com/u/824194?v=4" width="50">[pipermerriam](https://github.com/pipermerriam) commented at [2016-05-25 15:16](https://github.com/ethereum/solidity/issues/597#issuecomment-221609070):

Ok, so after reading up on storage layouts...

```
contract MyContractV1 {
    uint a;
    bytse32 b;
}
```

In this example, `a` should be stored in slot 0 and `b` in slot 1.  

Now, consider I _upgrade_ it to the following.

```
contract MyContractV2 {
    int c;
    uint a;
    bytes32 b;
}
```

This would end up with `c` stored in slot 0, `a` in 1, and `b` in 2 which would break things.

So, instead, I propose being able to do the following.

```
contract MyContractV2 {
    int c;
    uint a @ 0x0;
    bytes32 b @ 0x1;
}
```

The solidity compiler would see that `a` and `b` are designated for storage slots 0 and 1 respectively, and would then place `c` at the next available location, slot 2.

Does that make sense?  Is this possible?

#### <img src="https://avatars.githubusercontent.com/u/20340?v=4" width="50">[axic](https://github.com/axic) commented at [2016-05-25 15:23](https://github.com/ethereum/solidity/issues/597#issuecomment-221611370):

I was looking for a complementary/similar feature: the ability to disable packing. (i.e. currently if two storage parameters are each < 256 bits and together they fit into one slot, they are packed together.)

Ultimately the compiler could optimise the packing based on the frequency of changes to one ore more variables within.

With your suggestion this is a given, each marked variable gets its own slot.  I would use a different markup though:

```
storage(0) int a;
storage(1) bytes32 b;
```

#### <img src="https://avatars.githubusercontent.com/u/824194?v=4" width="50">[pipermerriam](https://github.com/pipermerriam) commented at [2016-05-25 15:29](https://github.com/ethereum/solidity/issues/597#issuecomment-221613047):

>  I would use a different markup though

the `@` was just the first thing that came to mind.  I like `storage(...)` better.

#### <img src="https://avatars.githubusercontent.com/u/9073706?v=4" width="50">[chriseth](https://github.com/chriseth) commented at [2016-05-25 16:06](https://github.com/ethereum/solidity/issues/597#issuecomment-221624605):

I think the tradeoff between introducing errors and decreasing readability is much better when just adding `int c` at the end. If you want, you can also use inheritance (let the upgraded contract inherit from the old contract).

#### <img src="https://avatars.githubusercontent.com/u/7756785?u=2893ea91743ac89ee3846d1f5c7209720e834129&v=4" width="50">[VoR0220](https://github.com/VoR0220) commented at [2016-05-25 20:23](https://github.com/ethereum/solidity/issues/597#issuecomment-221695748):

^ üëç  for the inheritance structure...it overall is cheaper and more cost effective to do it that way. I envision a lot of modularity around dapps in the future in regards to storage to better handle updates and save gas.

#### <img src="https://avatars.githubusercontent.com/u/20340?v=4" width="50">[axic](https://github.com/axic) commented at [2018-05-25 16:15](https://github.com/ethereum/solidity/issues/597#issuecomment-392107980):

This came up again as a discussion with @federicobond and I think a good middle ground could be to have an annotation (as proposed in https://github.com/ethereum/solidity/issues/597#issuecomment-221611370), but instead of marking a storage slot, it would rather have a string literal as a key, which is hashed to produce a 256-bit key for storage.

This would be more expensive (due to the fact of using 32-byte long constants and one couldn't combine multiple variables into a single slot), but might be justified for some.

When this annotation is missing, it would default to the current behaviour.

For syntax I propose:
```
int256 a storage_key("this_is_my_variable");
bytes32 b storage_key("and_this_too");
```

#### <img src="https://avatars.githubusercontent.com/u/824194?v=4" width="50">[pipermerriam](https://github.com/pipermerriam) commented at [2018-05-25 16:19](https://github.com/ethereum/solidity/issues/597#issuecomment-392109146):

@axic 

1. I like the hashed key approach
2. reasoning for not allowing specific slot to be specified?  foot gun?

#### <img src="https://avatars.githubusercontent.com/u/9073706?v=4" width="50">[chriseth](https://github.com/chriseth) commented at [2018-05-28 20:25](https://github.com/ethereum/solidity/issues/597#issuecomment-392598341):

I really don't think solidity should have such low-level impact on the storage location. If you want to dislocate storage variables, why not use structs or a mapping to structs?

#### <img src="https://avatars.githubusercontent.com/u/151065?u=0fc51dca2aa80373f8d417e826ca8ef5568525f6&v=4" width="50">[gnidan](https://github.com/gnidan) commented at [2018-07-20 12:11](https://github.com/ethereum/solidity/issues/597#issuecomment-406582568):

One more possible other solution:

```solidity
contract MyContract {
  storage("some-collection") {
    uint foo;
    uint bar;
  }

  storage("other-collection") {
    mapping (uint => bool) qux;
    MyStruct baz;
  }
}
```

The advantage of this is that contracts could define blocks of variables that are colocated in storage, but providing gaps, to extend structs later, etc.

#### <img src="https://avatars.githubusercontent.com/u/429604?u=8f63ca38c804c79ee0b933d57c1c535c7b8a088a&v=4" width="50">[spalladino](https://github.com/spalladino) commented at [2018-09-05 16:40](https://github.com/ethereum/solidity/issues/597#issuecomment-418798622):

Just throwing this as an idea: given that this need arises from avoiding clashes when working with upgradeability, wouldn't it make sense to just avoid clashing by storing all variables in a hashed location, similar to how a mapping works? We could either store all variables from the same contract/struct together (the hash being a contract identifier, and variables are stored at offsets of that hash), or all individual variables in sparse hashed locations.

The issue remains on how to generate an identifier for a contact, to ensure there are no clashes between different contracts, but that identifier is more robust than a simple name. Maybe requiring a special constant with a random value for every contract that will use this approach, similar to old [Java's `serialVersionUID`](https://docs.oracle.com/javase/7/docs/api/java/io/Serializable.html)?

#### <img src="https://avatars.githubusercontent.com/u/20340?v=4" width="50">[axic](https://github.com/axic) commented at [2019-10-29 17:18](https://github.com/ethereum/solidity/issues/597#issuecomment-547534830):

There was also a lengthy related discussion in #4017.

#### <img src="https://avatars.githubusercontent.com/u/1347491?v=4" width="50">[ekpyron](https://github.com/ekpyron) commented at [2020-01-14 10:19](https://github.com/ethereum/solidity/issues/597#issuecomment-574104165):

This came up again with #7891 .

If we want to expose really general control we need three components:
 - storage slot
 - offset in the storage slot
 - number of bytes reserved

Natural restrictions would apply (violating would result in compile time errors):
- ``offset + sizeOfType <= 32``
- ``numberOfBytesReserved >= sizeOfType``
- we could in a first version have ``(offset + numberOfBytesReserved) % 32 == 0`` and only later decide whether to lift that
 - no overlap with a previously declared variable is possible

I would suggest to make all such specifiers optional. Variables without specifiers *before* any variables with specifiers will be assigned slots as before.
For variables without specifiers *after* any variables with specifiers there are two options:
 - continue to put them after the last variable without specifier unless this is in conflict with another variable - if that's the case, move past it (I dislike this)
 - continue assigning storage locations after the last occupied storage location so far (including variables with specifiers) (I prefer this)


For the purpose of inheritance: locations are assigned just as if it was one flat contract containing all variables in the order of C3 linearization.

Example (we can always decide on a different syntax):
```
contract A {
  uint256 a; // will occuply full slot 0
  // slots 1 and 2 will remain unused
  storage{slot: 3, offset: 0, reserved: 32} bool b; // will occupy full slot 3

  storage{slot: 4, offset: 1} bool c; // will occupy the second byte in slot 4
  storage{slot: 4, offset: 0} bool d; // will occupy the first byte in slot 4
  storage{slot: 4, offset: 16} uint128 d; // will occupy the second half of slot 4

  uint128 e; // will occupy the first half of slot 5

  storage{slot: 5, offset: 16} uint128 f; // will occupy the second half of slot 5

  storage{slot: 6, offset: 0} bool g; // will occupy first byte in slot 6
  bool h; // will occupy second byte in slot 6
  storage{slot: 6, offset: 2, reserved: 2} bool i; // will occupy third byte in slot 6
  bool j; // will occupy fifth byte in slot 6
  storage{slot: 6, offset: 16, reserved: 48} uint128 k; // will occupy second half of slot 6
  // slot 7 will remain unused
  uint128 l; // will use the first half of slot 8
}
```


An alternative notation-wise would be to merge slot and offset into a single byte offset that is then split into ``slot = byteOffset/32`` and ``offset = byteOffset%32`` (to which the same restrictions would apply). A copy of the example above using this notation:

```
contract A {
  uint256 a; // will occuply full slot 0
  // slots 1 and 2 will remain unused
  storage{offset: 96, reserved: 32} bool b; // will occupy full slot 3

  storage{offset: 129} bool c; // will occupy the second byte in slot 4
  storage{offset: 128} bool d; // will occupy the first byte in slot 4
  storage{offset: 144} uint128 d; // will occupy the second half of slot 4

  uint128 e; // will occupy the first half of slot 5

  storage{offset: 160} uint128 f; // will occupy the second half of slot 5

  storage{offset: 192} bool g; // will occupy first byte in slot 6
  bool h; // will occupy second byte in slot 6
  storage{offset: 194, reserved: 2} bool i; // will occupy third byte in slot 6
  bool j; // will occupy fifth byte in slot 6
  storage{offset: 208, reserved: 48} uint128 k; // will occupy second half of slot 6
  // slot 7 will remain unused
  uint128 l; // will use the first half of slot 8
}
```

#### <img src="https://avatars.githubusercontent.com/u/1347491?v=4" width="50">[ekpyron](https://github.com/ekpyron) commented at [2020-01-14 10:30](https://github.com/ethereum/solidity/issues/597#issuecomment-574108837):

Another alternative would be to require specifying the location for *all* variables, if the location is specified for *any* variable.

Also we could at a later point allow compile time evaluated expressions in the specifier, i.e.:
```
storage{slot: keccak256("some_key")} uint256 some_key;
```
Although we'd need to consider that one could construct those to specifically collide with some mapping key, so this would be dangerous.

Although that's also true for choosing some specific value for ``slot: `` that happens to be the location of some mapping element.

#### <img src="https://avatars.githubusercontent.com/u/9073706?v=4" width="50">[chriseth](https://github.com/chriseth) commented at [2020-01-14 14:17](https://github.com/ethereum/solidity/issues/597#issuecomment-574194676):

Maybe we should gather some data about how this feature would be used. One use is avoiding clashes during upgrades, another is having more efficient use of storage by combining small variables in a certain way. I think just providing full flexibility all the time might not be the way to go as it is too easy to get wrong. So it could already be enough to only allow hashed locations and another way to specify which variables to combine (without specifying the offset exactly) or when to insert "start a new slot here".

#### <img src="https://avatars.githubusercontent.com/u/1347491?v=4" width="50">[ekpyron](https://github.com/ekpyron) commented at [2020-01-14 14:53](https://github.com/ethereum/solidity/issues/597#issuecomment-574211168):

What can "go wrong"? Or in particular, what can go wrong that we can't easily detect at compile time?
I'd argue that it makes more sense to provide a general solution and, if deemed necessary, restrict it to simple cases (as in restrict to some particular kinds of values for ``slot``, etc. - e.g. restricting to only supporting "start a new slot here" would be to require ``slot`` to be the "current slot" plus one and require ``offset`` to be zero).

That way we can always extend the very same solution to support more cases, instead of needing breaking changes and new language features...

#### <img src="https://avatars.githubusercontent.com/u/429604?u=8f63ca38c804c79ee0b933d57c1c535c7b8a088a&v=4" width="50">[spalladino](https://github.com/spalladino) commented at [2020-01-24 13:43](https://github.com/ethereum/solidity/issues/597#issuecomment-578134850):

> One use is avoiding clashes during upgrades

For the sake of upgrades, it'd seem that the only requirement is to be able to assign an immutable `id` to a variable, which should be deterministically mapped to a slot (like the `storage{slot: keccak256("some_key")}` proposed above). It's not really important _where_ in the storage the variable is kept.

As for [EIP2330](https://github.com/ethereum/EIPs/pull/2330) linked above, the requirements are pretty much the same. As long as there is a deterministic process for calculating the storage slot, the actual slot can then be just exposed in the ABI for any consumers.

#### <img src="https://avatars.githubusercontent.com/u/824140?u=53881f3dec84b4da3cd4ca1b790523ae400e9fdc&v=4" width="50">[KaiRo-at](https://github.com/KaiRo-at) commented at [2020-04-29 17:05](https://github.com/ethereum/solidity/issues/597#issuecomment-621342019):

To implement contract following [EIP 1822](https://eips.ethereum.org/EIPS/eip-1822) and/or [EIP 1967](https://eips.ethereum.org/EIPS/eip-1967), the capability to define a specific slot would be required. Right now, this needs to be done via inline assembly...

#### <img src="https://avatars.githubusercontent.com/u/11246316?u=b1879af21c58336a58b5b41376db8eade5006d51&v=4" width="50">[junderw](https://github.com/junderw) commented at [2020-07-23 22:48](https://github.com/ethereum/solidity/issues/597#issuecomment-663269134):

After reading this issue, and thinking about the issue, this is my proposed solution.

1. add the keyword `deterministic`
2. it can only be used with declared storage variables
3. at compile time the slot used for `uint256 deterministic myNumber;` is `keccak256('myNumber')`
4. basically, similar to `immutable` which doesn't use storage, `deterministic` variables will be removed when calculating the sequential slots of each variable, the keccak256 is calculated at compile time and used for all instances.
5. upgradable contracts can now rely on "this variable name will always be a specific storage slot"
6. If it sees the same `variable name` in multiple inherited contracts with mixed `deterministic` states it should throw an error at compile time saying "can't use deterministically declared variable non-deterministically"

It seems simple enough to remove complexity but accomplish some of the major goals of this thread.

However, it seems like this thread has grown with a list of reasons and use cases which can only be satisfied by increasingly complex low level access which is difficult to implement without adding a foot cannon.

Edit: Thinking about it more, it might be sufficient to commit only to the variable name, as someone using this feature would probably make their variable names more descriptive `address deterministic openZepplinProxyImplementation;` which should probably throw an error if an inherited contract tries to use `uint256 deterministic openZepplinProxyImplementation;` which could be another foot cannon.

Edit2: I have a low-deploy-gas-cost proxy contract that I optimized the bytecode for, and it would be great to use single byte storage slots (ie. 0xff) without needing to create 255 dummies... I just tried upping my storage slot for the proxy to PUSH32 with a random hash instead of the 0 I'm using right now, it bumped my deploy cost from 80k to 100k (since I have 1 PUSH in the deploy code and 2 PUSHes of it in the contract code.)... so I would definitely also enjoy the ability to specify an arbitrary value for the slot as well... that said, my use case is extremely niche so I understand not accommodating it.

#### <img src="https://avatars.githubusercontent.com/u/20340?v=4" width="50">[axic](https://github.com/axic) commented at [2020-07-29 21:05](https://github.com/ethereum/solidity/issues/597#issuecomment-665927241):

Copying the suggestion from @dominicletz from #7593:

> A new keyword `fixed(@N)` is proposed that can be used to define fixed slot position in interfaces.
> 
> ```
> interface ContractAddressMap {
>    public fixed(@5) mapping(bytes32=>address) addr;
> }
> ```

#### <img src="https://avatars.githubusercontent.com/u/14597409?v=4" width="50">[SchoofsKelvin](https://github.com/SchoofsKelvin) commented at [2021-07-10 22:38](https://github.com/ethereum/solidity/issues/597#issuecomment-877712913):

Here's my spin on specifying storage slots, based on existing EIPs that could benefit from this:

- Allow specifying the location as a (compile-time calculable) constant `uint256`/`bytes32` (see examples)
- Syntax-wise, appending `at (<slot>)` (or `at(<slot>, <offset>)`) seems more intuitive and readable than using e.g. `@`
  - Offset would be optional and default to 0. Optionally, this might also allow the syntactic sugar `at <slot>`
  - The exact syntax doesn't matter too much and the previously suggested `storage_key("key")` works too
  - The `fixed(@N)` syntax from #7593 could work too, if `N` can be more than just an integer
    - The `EXTSLOAD` opcode from their EIP on the EVM level doesn't care how Solidity compiles their `fixed(@N)` syntax
    - Their Solidity suggestion would actually benefit from allowing keys and `byte32`s over just integers
  - The only change I'd add is that instead of accepting (only) strings that'll be hashed, it also accepts `uint256`/`bytes32`s. This is to support e.g. [EIP-1967](https://eips.ethereum.org/EIPS/eip-1967) where we substract 1 after hashing the key
  - In my examples, I'll only be using `uint256`/`bytes32`s, but again, accepting to-be-hashed strings on top of that seems fine
- Exclude "location-specified" storage fields from the sequential storage slot assignment logic (see `someVarN` in 1st example)
  - Basically, the storage slots for non-specified storage fields should be unaffected by the presence of specified storage fields
  - This also means that existing contracts should compile to the exact same bytecode as before this feature gets enabled
- We can make use of the fact that locations are known at compile time to e.g. warn for using the same slots, overlap, ...
- Perhaps we could even allow aliasing storage fields, e.g. `referencing(<state variable>)` (see `NewFacet.sol` in 2nd example)

This is partly with my (although limited) experience working with Solidity and proxy contracts, the feedback in this issue and the mentioned EIPs. It's both an attempt at covering as much of the use cases and requirements, while also seeing if there's any (planned) progress on this issue. _I've noticed now that I'm rereading it that this is quite a big comment, hopefully that isn't too much of an issue._

# Example 1 (simple proxy)

Example showing how it behaves on its own and how it interacts with non-specified slots:
```solidity
contract SomeProxy {
    uint256 private someVar1; // storage slot 0x0 (in this case starting at 0x0 because there are no inherited fields)
    uint256 private someVar2 = 5; // storage slot 0x1

    uint256 public something1 at(0xAA112233) = 99; // storage slot 0xAA112233

    // This would produce an error/warning because it uses the same storage slot as `something1`
    uint256 public something2 at(0xAA112233) = 123; // storage slot 0xAA112233

    uint256 public someVar3; // storage slot 0x3 (right behind `someVar2`, thus ignoring `something1` and `something2`)

    bytes32 constant IMPLEMENTATION_SLOT = bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1);
    // ^ 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc 

    // Not specifying the offset, so can use the syntactic sugar version without the brackets
    address private _implementation at IMPLEMENTATION_SLOT; // storage slot 0x360894...

    // ....
}
```
_the `_implementation` part is based on the storage slots specified in [EIP-1967](https://eips.ethereum.org/EIPS/eip-1967)_

# Example 2 (diamond storage)

This could also work in interfaces, which helps a lot with diamond storage ([EIP-2535](https://eips.ethereum.org/EIPS/eip-2535)), related to #9551. In this example:
- `OldFacet.sol` specifies a standalone diamond facet with a storage struct at `keccak256('diamond.storage.OldFacet')`
  - It doesn't use `DiamondStorages` from `Storage.sol` for whatever reason. Might be an extern facet, or developed earlier
- `Storage.sol` specifies an interface `DiamondStorages` with all known diamond storages, at their proper storage slots
- `NewFacet.sol` specifies a new diamond facet that also makes use of OldFacet's storage by extending `DiamondStorages`
  - The contract inherits the field with the specified storage slots, without having to redeclare them
  - While the `DiamondStorages` needs to define the storages your new facet uses, it could instead define all storages part of the diamond. In that case, should "overlapping storage slots" warnings be enabled, your diamond gets checked for this issue

```solidity
// OldFacet.sol
bytes32 constant OLD_FACET_STORAGE_SLOT = keccak256("diamond.storage.OldFacet");

struct OldFacetStorage {
    // ...
}

contract OldFacet {
    // Directly registers the storage field/slot here, e.g. an externally developed or pre-Storage.sol contract
    OldFacetStorage storage at OLD_FACET_STORAGE_SLOT;
    // ....
}


// Storage.sol
import "./OldFacet.sol";
import "./NewFacet.sol";

interface DiamondStorages {
    OldFacetStorage oldFacetStorage at OLD_FACET_STORAGE_SLOT;
    NewFacetStorage newFacetStorage at NEW_FACET_STORAGE_SLOT;
    // ....
}


// NewFacet.sol
import "./DiamondStorages";

bytes32 constant NEW_FACET_STORAGE_SLOT = keccak256("diamond.storage.NewFacet");

struct NewFacetStorage {
    // ...
}

// Makes use of Storage.sol instead of specifying the storage field/slot for every (known/used) faucet's storage
contract NewFacet is DiamondStorages {
    // Optional "aliasing storage fields" which can be handy for shortening long names to shorter ones
    NewFacetStorage private s referencing(newFacetStorage);

    function banana() public returns (uint256) {
        // Using OldFacet's storage as declared in `DiamondStorages` in `Storage.sol`
        // Using NewFacet's storage as declared by `s`, using the same slot as `newFacetStorage` in `DiamondStorages`
        return oldFacetStorage.apple + s.durian;
    }
}
```

Since all the used/known diamond storages are all defined and known at compile-time, the compiler could (as part of later feature requests) check whether any storage slots overlap each other.

# Example for #7593

Example of how this would benefit #7593 should non-integer values for `N` be allowed:

```solidity
interface ContractAddressMap {
    public mapping(bytes32=>address) addr at keccak256('ENS.addr');
    // or different versions of their syntax that allows non-integer `N` values:
    public fixed(@keccak256('ENS.addr')) mapping(bytes32=>address) addr; // keep `@` to differentiate from e.g. `map_v1`
    public fixed(keccak256('ENS.addr')) mapping(bytes32=>address) addr; // get rid of `@`, force 1st argument to be location
    public fixed('ENS.addr') mapping(bytes32=>address) addr; // assuming using a direct string implies `keccak256`
}

contract Resolver is ContractAddressMap {
    // ...
}
```

Mind that this also more or less solves their issue regarding conflicts, as compared to using `fixed(@5)`, it's a lot harder to have clashes when using e.g. `keccak256('ENS.addr')`. Suggesting these kind of modifications to the EIP-2330 draft seems doable and beneficial for everyone.

# Expected improvement from #3157

Should #3157 be implemented, this can help a lot with readability with complex keys later on, e.g. for our first example:
```solidity

function proxy_slot(string key) public pure returns(bytes32) {
    return bytes32(uint256(keccak256(abi.encodePacked('eip1967.proxy.'), key)) - 1);
}

contract SomeProxy {
    // Points to the slot at `bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1)`
    // aka `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`
    address private _implementation at proxy_slot("implementation");
}
```

# Deterministic storage slots

This feature request is purely to use statically assigned storage slots, as specified by those EIPs or used in the diamond (storage) pattern. The whole "deterministic storage slot" idea is also interesting, but more of a separate feature from (or on top of) specifying specific storage locations. It's worth mentioning that the latter could still be relatively easily done should (the static part of) this feature be implemented:

```solidity
contract DeterministicFields {
    address private _owner at keccak256('_owner');

    // or again, if we have #3157 and support pure functions in the contract itself during compile-time:
    function storage_slot(string key) internal pure returns(bytes32) {
        return bytes32(uint256(keccak256(abi.encodePacked('DeterministicFields.'), key)) - 1);
    }
    address private _admin at storage_slot('_admin');
    // ^ Would use storage slot `keccak256('DeterministicFields._admin')`, making it less likely to clash
    // with storage slots from other contracts using an `_admin` field (e.g. in base contracts or other facets in a diamond)
}
```

#### <img src="https://avatars.githubusercontent.com/u/137030?v=4" width="50">[cameel](https://github.com/cameel) commented at [2021-10-01 19:02](https://github.com/ethereum/solidity/issues/597#issuecomment-932480697):

In https://github.com/ethereum/solidity/issues/8353#issuecomment-932474378 I have described another solution, similar to what @gnidan and @spalladino suggested above (see https://github.com/ethereum/solidity/issues/597#issuecomment-406582568, https://github.com/ethereum/solidity/issues/597#issuecomment-418798622).

In short, you can already use a mapping of structs to give your contract a set of variables at a storage location deterministically computed from some key:
```solidity
contract MyContract {
    struct State {
        uint variable1;
        address variable2;
    }

    mapping (string => State) states;

    function f() public returns (uint) {
        return states["MyContract"].variable1;
    }
}
```

We could just add a bit of syntax sugar on top of that and have a simple solution that might be good enough in most cases. I.e. this would generate bytecode identical to the above:
```solidity
contract mapping MyContract {
    uint variable1;
    address variable2;

    function f() public returns (uint) {
        return variable1;
    }
}
```
Since it would be a new contract variety, it would be fully backwards-compatible.

#### <img src="https://avatars.githubusercontent.com/in/15368?v=4" width="50">[github-actions](https://github.com/apps/github-actions) commented at [2023-02-12 12:04](https://github.com/ethereum/solidity/issues/597#issuecomment-1427015783):

This issue has been marked as stale due to inactivity for the last 90 days.
It will be automatically closed in 7 days.

#### <img src="https://avatars.githubusercontent.com/u/1347491?v=4" width="50">[ekpyron](https://github.com/ekpyron) commented at [2023-02-13 20:35](https://github.com/ethereum/solidity/issues/597#issuecomment-1428644895):

We have multiple issues along this (see e.g. the list in https://github.com/ethereum/solidity/issues/13466#issuecomment-1419319182) - I'm marking this one here unstale and as ``must have eventually``, since it's the most generic and most likely version to be implemented eventually.

#### <img src="https://avatars.githubusercontent.com/u/708945?v=4" width="50">[yoavw](https://github.com/yoavw) commented at [2023-05-07 20:24](https://github.com/ethereum/solidity/issues/597#issuecomment-1537533170):

This issue has become more critical with the growing popularity of account abstraction, so I would like to resume this discussion.

Account abstraction adds a new challenge that, to the best of my knowledge, no other contract has faced before.

The user owns the account, typically a proxy, and may occasionally wish to switch to a different implementation as the needs change.  E.g. switch between Safe and Argent.  Unlike other proxy situations where new implementations use a compatible storage layout, or at least the new implementation is aware of the old one and can perform a conversion, now we're dealing with implementations that are not aware of each other.

Currently, most account implementations start at storage slot zero.  When switching implementations, the user may inadvertently end up with things like shadow signers, e.g. [this Safe](https://app.safe.global/settings/setup?safe=gor:0xD23e1E5F40Cae07E56E30Cdc710d9b107abD60DB) which seems to have one valid signer, but in fact has 20 invisible signers who can actually [transact](https://goerli.etherscan.io/tx/0xb09dcce42c3a6c419eda1a2f9715b87c6f5dd4b73c5a643fe13809509cf91dd5#eventlog) in the Safe.

There is no safe way for users to migrate between account implementations, unless each account uses a different storage base.  I would like to propose a pragma for doing so:

`pragma storage_base <value>;`

When present, the compiler calculates keccak(value) and uses it as a hardcoded offset for storage access.  A typical value would be <proj_name>.<layout_version>.

The pragma only sets the offset of next items, and following items are incremented by one, as usual.  Therefore if the pragma appears multiple times, each pragma forms a "logical group" of member fields.

A buggy/malicious account would still be able to bypass it and access other storage offsets, but it'll require asm code and therefore attract auditors' attention.  Pure solidity code will only access storage determined by the `storage_base` value.

#### <img src="https://avatars.githubusercontent.com/u/13174375?u=52d702cb6bec53b561afa293cf9cd53ef7a63924&v=4" width="50">[hrkrshnn](https://github.com/hrkrshnn) commented at [2023-05-10 17:45](https://github.com/ethereum/solidity/issues/597#issuecomment-1542583267):

@yoavw Typically what people do to get this is to add a state variable `uint[1000] junk`.

```solidity
// Inherit this for leaving out the first 100 slots
abstract contract storageBase {
    uint[100] junk;
}
```

Would that be a reasonable way to achieve the same?

#### <img src="https://avatars.githubusercontent.com/u/708945?v=4" width="50">[yoavw](https://github.com/yoavw) commented at [2023-05-10 18:26](https://github.com/ethereum/solidity/issues/597#issuecomment-1542628622):

> Would that be a reasonable way to achieve the same?

I'm not sure, since the storage base has to be at a random location in the storage space, typically `keccak(project_name)` to avoid conflicts between different account implementations.  solc would complain if contracts allocate an array half the size of the storage space.

Another issue is that a contract may need to access the storage base of another contract.  If they allocate these slots for an array, they won't be able to.  At least two cases require this:

1. Modules.  Some accounts are modular and a module sometimes need to access the storage of the account's core implementation.  The modules use different storage bases to avoid conflicts but if they use an array they won't be able to access lower slots.  Suppose the core account implementation starts at `S1` and a module starts at `S2`, with `S1 < S2`.  The module will have the `S1` space inside its `junk` array and won't be able to access these variables.

With the pragma I suggested, it would be accessed like this:
```solidity
contract SafeStorage {
  #pragma storagebase "safe.core"
  uint threshold;
  mapping (address=>address) owners;

  #pragma storagebase "safe.modules.niftymodule"
  mapping (address=>address) someModuleMapping;
  uint someModuleVariable;
}
```

2. Migration function.  Suppose the user is switching from SimpleAccount to Safe, which use different storage bases.  The transaction that changes the implementation will have to import signer from the SimpleAccount storage base and add it to the Safe storage base as a signer.  If SimpleAccount's storage base is lower than Safe's, then Safe won't be able to perform the migration.

With the pragma I suggested, a Safe migration module could be something like this:

```solidity
contract MigrateSimpleAccountToSafe is OwnerManager {
  #pragma storagebase "safe.core"
  uint threshold;
  mapping (address=>address) owners;

  #pragma storagebase "simpleaccount"
  address public simpleAccountOwner;

  function migrate() public {
    addOwnerWithThreshold(simpleAccountOwner, 1);
    simpleAccountOwner = address(0);
  }
}
```

#### <img src="https://avatars.githubusercontent.com/u/1347491?v=4" width="50">[ekpyron](https://github.com/ekpyron) commented at [2023-05-11 05:40](https://github.com/ethereum/solidity/issues/597#issuecomment-1543368078):

Pragmas are a mechanism for modifying file-based compiler settings - I wouldn't consider them a good match for this purpose.
My preferred approach would still be to have specific syntax for specifying the storage location of any specific storage slot, which would result in the following slots to continue using storage after the previous slot as usual, until the next slot has specified a specific storage location.

So in your example something like
```solidity
contract MigrateSimpleAccountToSafe is OwnerManager {
  storage{slot: keccak256("safe.core")} uint threshold;
  mapping (address=>address) owners;

  storage{slot: keccak256("simpleaccount")} address public simpleAccountOwner;

  function migrate() public {
    addOwnerWithThreshold(simpleAccountOwner, 1);
    simpleAccountOwner = address(0);
  }
}
```
(potentially with different syntax, but with regular language keywords decorating the slots instead of pragmas)

#### <img src="https://avatars.githubusercontent.com/u/708945?v=4" width="50">[yoavw](https://github.com/yoavw) commented at [2023-05-11 11:43](https://github.com/ethereum/solidity/issues/597#issuecomment-1543844553):

> Pragmas are a mechanism for modifying file-based compiler settings

It's mostly a file-based property and should affect everything in that file.  Except for rare cases like a migration contract or a module accessing the account's core storage, the pragma is set at the beginning of the file and affects all variables defined in that file.

We could also have a syntax for variable-level setting, but I think we need a way to do it for the entire file.  Otherwise we risk missing some variable and it gets based at slot 0 rather than the account's storage base.  None of the variables should be based at zero if the implementation might change.

In the above example, `threshold` is based at `keccak256("safe.core")`, but wouldn't `owners` be based at zero rather than `keccak256("safe.core")+1`?  If it's based at zero, it would conflict with any account implementation that also happens to have something at zero due to making the same mistake?

The intent we'd like to signal to the compiler is "from here on, variables start at slot S and grow from there".  If pragma is not the appropriate way to signal something like this, what would be the right way?

#### <img src="https://avatars.githubusercontent.com/u/1347491?v=4" width="50">[ekpyron](https://github.com/ekpyron) commented at [2023-05-11 12:29](https://github.com/ethereum/solidity/issues/597#issuecomment-1543908356):

It's not a file-based property at all - it's a property at most of a contract, but really of its state variables - pragmas are definitely the wrong tool for this. I mean, even in your example, it's a property that changes more than once within one contract in a file :-).

> In the above example, threshold is based at keccak256("safe.core"), but wouldn't owners be based at zero rather than keccak256("safe.core")+1? If it's based at zero, it would conflict with any account implementation that also happens to have something at zero due to making the same mistake?

In my last comment I said "specifying the storage location of any specific storage slot, which would result in the following slots to continue using storage after the previous slot as usual" - storage slots are generally not assigned globally but in relation to the last slot (since there may be packing involved). So whenever we'd specify the specific slot for any state variables, the next variable would continue continuously from there, and in particular in the example ``owners`` would live at ``keccak256("safe.core")+1``. That's the only sane choice, I'd argue, since interleaving different continuous storage regions would be horribly confusing.

> The intent we'd like to signal to the compiler is "from here on, variables start at slot S and grow from there". If pragma is not the appropriate way to signal something like this, what would be the right way?

I'd argue that the right way to do this is specifying the slot directly for the first variable that's supposed to live at slot S - and then let the compiler append the next slot after the previous one like it always does.

#### <img src="https://avatars.githubusercontent.com/u/708945?v=4" width="50">[yoavw](https://github.com/yoavw) commented at [2023-05-11 12:58](https://github.com/ethereum/solidity/issues/597#issuecomment-1543960967):

ok, no pragma then :)

Let's go with the syntax you're suggesting.

One case I'm unsure of, is inheritance.  A pragma would have been placed before the contract definition, affecting everything that comes after it.  With the above syntax, how would the following be handled?

```solidity
abstract contract Ownable {  // OpenZeppelin Ownable.sol - imported library, not modified locally.
  address private _owner;
  ...
}

contract SomeAccount is Ownable {
  storage{slot: keccak256("someaccount")} mapping(address => address) internal modules;
  ...
}
```

My understanding is that `Ownable._owner` gets allocated before `SomeAccount.modules`.  Wouldn't `_owner` end up in slot 0 then?

#### <img src="https://avatars.githubusercontent.com/u/1048544?v=4" width="50">[wranai](https://github.com/wranai) commented at [2023-07-17 08:56](https://github.com/ethereum/solidity/issues/597#issuecomment-1637636523):

Over 7 (SEVEN!) years into this thread about something obviously useful and desirable, what legitimate arguments go against just rolling with something simple, stupid, and safe:
```solidity
contract Contract {
    mapping (address=>uint256) stuff at keccak256('stuff');
    // ...
}
```
or
```solidity
contract Contract {
    mapping (address=>uint256) stuff @ keccak256('stuff');
    // ...
}
```

Not having this feature was a design flaw right from the beginning, probably due to the mistaken belief held at the time that "code is law, code is immutable," which allowed for abstracting storage address away since nobody would look at it again.

#### <img src="https://avatars.githubusercontent.com/u/708945?v=4" width="50">[yoavw](https://github.com/yoavw) commented at [2023-08-03 01:45](https://github.com/ethereum/solidity/issues/597#issuecomment-1663177309):

> Over 7 (SEVEN!) years into this thread about something obviously useful and desirable, what legitimate arguments go against just rolling with something simple, stupid, and safe

Yes please!  Something simple and stupid is better than nothing at all.  We need this.

As for this specific syntax, it'll be a bit error-prone since the developer needs to manually handle the storage counter or use different strings for each variable:

```
contract Contract {
    mapping(address=>uint256) mapping1 at keccak256('stuff');
    uint256 array1[10] at keccak256('stuff')+1;
    uint256 num at keccak('stuff')+11;
    // ...
}
```

or 

```
contract Contract {
    mapping(address=>uint256) mapping1 at keccak256('Contract.mapping');
    uint256 array1[10] at keccak256('Contract.array1');
    uint256 num at keccak('Contract.num');
    // ...
}
```

I think being able to set the storage base, and then all subsequent declarations continue from the new base, is more readable and less error prone.  But at this point anything would be better than waiting another 7 years.

#### <img src="https://avatars.githubusercontent.com/u/22412996?u=d91a07517a0c02cb39e45f71a6d0f1f0c5bbd9cb&v=4" width="50">[zemse](https://github.com/zemse) commented at [2023-12-15 07:27](https://github.com/ethereum/solidity/issues/597#issuecomment-1857402416):

I saw the talk by openzeppelin at solidity summit. They have mentioned that their v5 uses storage locations as [here](https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/9d6fe06f819031686f32f2084b02ac817b93cb5d/contracts/access/OwnableUpgradeable.sol#L27-L35).

Problem: this does not include the info in the storage interface in the solc output.

It would be great if solidity supports specifying the storage locations so that the storage interface will contain all these values so that tools can utilize this info. Is there any active issue regarding this?

#### <img src="https://avatars.githubusercontent.com/u/708945?v=4" width="50">[yoavw](https://github.com/yoavw) commented at [2023-12-15 23:35](https://github.com/ethereum/solidity/issues/597#issuecomment-1858609034):

> It would be great if solidity supports specifying the storage locations so that the storage interface will contain all these values so that tools can utilize this info.

Right. It should be a compiler level feature, not a hack by the contract itself.



> Is there any active issue regarding this?

This issue is still open :)  but it's been here since 2016.  Can we increase its priority somehow?

#### <img src="https://avatars.githubusercontent.com/u/481465?v=4" width="50">[frangio](https://github.com/frangio) commented at [2023-12-16 04:34](https://github.com/ethereum/solidity/issues/597#issuecomment-1858716162):

@zemse asks if there is an open issue discussing the problem that struct types as used in ERC-7201 will be ignored by solc when producing the `storageLayout` compiler output. This is because the struct type is not used in any state variable that solc is aware of, the type is only used as the type of a storage pointer returned by a function.

I've discussed this with the Solidity team in the past on Gitter, but did not open an issue. I do think it should be fixed. We had to implement a pretty complex [workaround](https://github.com/OpenZeppelin/openzeppelin-upgrades/blob/%40openzeppelin/upgrades-core%401.32.1/packages/core/src/utils/make-namespaced.ts#L15-L16) because of it, for the storage safety checks implemented in OpenZeppelin Upgrades.

#### <img src="https://avatars.githubusercontent.com/u/10339043?u=e7cb87b0a9d2f3dc20c334e191670300682a0537&v=4" width="50">[lucemans](https://github.com/lucemans) commented at [2024-05-24 10:55](https://github.com/ethereum/solidity/issues/597#issuecomment-2129241889):

EIP-7702 was here.

#### <img src="https://avatars.githubusercontent.com/u/708945?v=4" width="50">[yoavw](https://github.com/yoavw) commented at [2024-05-24 22:45](https://github.com/ethereum/solidity/issues/597#issuecomment-2130475981):

Happy 8th birthday to this issue! üéâü•≥

And more seriously, with EIP-7702 this becomes critical.  EOAs will be delegating to different contracts, all of which may write to storage slots in the EOA itself.  Conflicts are pretty much guaranteed if we don't make it easy to use different storage bases.

#### <img src="https://avatars.githubusercontent.com/u/137030?v=4" width="50">[cameel](https://github.com/cameel) commented at [2024-05-29 17:25](https://github.com/ethereum/solidity/issues/597#issuecomment-2137917945):

We discussed this with @yoavw on the design call today. The biggest hangup here is really that none of the solutions proposed so far seem to both be simple and address all the relevant use cases. One that would be the most appealing is letting the user specify an offset for a particular variable and have all the variables defined after that just follow it. The problem is that contract inheritance severely limits its usefulness since the variables of the base contracts are laid out first.

Still, we're aware that EIP-7702 is making the issue more pressing and we need to address it quickly. We decided that we're going to introduce a simple solution that will at least address this particular use case without conflicting with possible extensions in the future.

We'll make it possible to specify a base storage offset for a contract as a whole (including its inheritance hierarchy). For now it will only be possible to specify it for the most derived contract, but we may consider relaxing that restriction if there are good reasons for it. The offset may be specified indirectly (e.g. be a hash of some identifier, which is the common way to do it), but must still be computable at compilation time.

Optionally, we may consider including a mechanism for moving the variables of a specific contract out of that flow, to give them an independent location, which might mesh better with upgradeable contracts. But then there's the question if the location should be completely fixed or depend on the base offset?

That's the general outline, but we still need a concrete syntax proposal.

We're also interested in feedback on that solution. Is there anything it's missing in the context of EIP-7702?

#### <img src="https://avatars.githubusercontent.com/u/481465?v=4" width="50">[frangio](https://github.com/frangio) commented at [2024-05-29 19:55](https://github.com/ethereum/solidity/issues/597#issuecomment-2138160467):

Decoupling storage location from inheritance linearization is important. What is the main challenge to going in that direction rather than just adding a global offset?

#### <img src="https://avatars.githubusercontent.com/u/708945?v=4" width="50">[yoavw](https://github.com/yoavw) commented at [2024-05-30 14:35](https://github.com/ethereum/solidity/issues/597#issuecomment-2139730726):

https://eips.ethereum.org/EIPS/eip-7201

#### <img src="https://avatars.githubusercontent.com/u/16929357?u=a148cf5f5bd8d1324a1044cc1bd38c6b6e1c74f1&v=4" width="50">[GregTheGreek](https://github.com/GregTheGreek) commented at [2024-05-30 14:46](https://github.com/ethereum/solidity/issues/597#issuecomment-2139770061):

In the case of 7702,  wouldn't it make more sense to set it globally at the contract level? For example instead of declaring the pragma on a per variable scope, we can set it globally

```
storagePragma

contract Contract {}
```

Where the contract code is keccak hashed, and thus every variable downstream is namespaced based on the contract that is currently deployed?

#### <img src="https://avatars.githubusercontent.com/u/708945?v=4" width="50">[yoavw](https://github.com/yoavw) commented at [2024-05-30 15:12](https://github.com/ethereum/solidity/issues/597#issuecomment-2139879381):

> In the case of 7702, wouldn't it make more sense to set it globally at the contract level?

Yes. I believe that's what the solidity team has in mind.  Set it globally in the most-inherited contract.

#### <img src="https://avatars.githubusercontent.com/u/63450340?v=4" width="50">[PowerStream3604](https://github.com/PowerStream3604) commented at [2024-05-31 03:21](https://github.com/ethereum/solidity/issues/597#issuecomment-2141164780):

@cameel @yoavw really glad to see this is making progress. I think this will be a big help for the EIP 7702 and for AA wallet implementations in general.

Curious to know if we have a draft or idea on how the syntax will work for setting the base storage slot from the latest comment?

Regarding the below comment:
> We'll make it possible to specify a base storage offset for a contract as a whole (including its inheritance hierarchy)

Does it imply that we'll use the final contract's base storage as a whole? `keccak256("ModularAccount")` in this case or would the storage be allocated in each contract's declared base storage slot?
```solidity
basestorage{slot: keccak256("Storage")} // Just assuming a possible syntax
contract Storage {
    address entryPoint;
    // ...
}

basestorage{slot: keccak256("ModularAccount")} // Just assuming a possible syntax
contract ModularAccount is Storage {
    mapping (bytes4=>address) selectorTomodules;
    // ...
}
```

#### <img src="https://avatars.githubusercontent.com/u/4210206?v=4" width="50">[nlordell](https://github.com/nlordell) commented at [2024-05-31 08:33](https://github.com/ethereum/solidity/issues/597#issuecomment-2141498314):

> We discussed this with @yoavw on the design call today. The biggest hangup here is really that none of the solutions proposed so far seem to both be simple and address all the relevant use cases.

Is there a summary of what those proposals are? This GitHub issue seems to _mostly_ describe proposals around specifying slots for specific fields, but not necessarily what the currently considered proposals for setting a storage namespace for entire contracts in the context of 7702.

---

Some random thoughts (although I don't have a concrete syntax proposal).

1. You could argue that base classes should be "storage namespace" agnostic, however derived contracts may want to have storage of a base class also part of its namespace. One possible syntax could be:
    ```solidity
    contract Foo is Bar{storage: 1337} {
    }
    ```
2. If you want to be very opinionated, then you could just (AFAIU, this is what @yoavw suggested in the past):
    ```solidity
    pragma storage namespace "MyNamespace";
    ```
    And just assign slots starting at `keccak256("foo") - 1` (instead of 0) and "grow downwards" in order to prevent issues around storage slots being at locations with known preimages (if that is a concern). This does, however, get a bit tricky with inheritance (what happens if two files use pragmas to different namespaces?) and I don't know if there are some ugly edge cases that I didn't think about.
3. Same as 2, but make it a compiler flag. This removes some ambiguity with inheritance and makes the storage namespace only apply to single compilation unit without introducing any additional language requirements at the downside of making it less obvious from code.

#### <img src="https://avatars.githubusercontent.com/u/4210206?v=4" width="50">[nlordell](https://github.com/nlordell) commented at [2024-05-31 13:19](https://github.com/ethereum/solidity/issues/597#issuecomment-2142152107):

As a follow up suggestion, another possible solution is to have something like:

```solidity
storage namespace Foo is Bar {
   slot: 1337
}
```

Which would output bytecode for a "contract" named Foo whose implementation is Bar with different field storage slot assignment as described above (where the field that is assigned storage slot 0 is instead assigned storage slot 1337, etc.). This eliminates ambiguity around what happens when base and derived contracts start specifying this, since the "storage namepace" is not a contract that can be inherited from.

> All syntax suggestions are just placeholders

#### <img src="https://avatars.githubusercontent.com/u/16929357?u=a148cf5f5bd8d1324a1044cc1bd38c6b6e1c74f1&v=4" width="50">[GregTheGreek](https://github.com/GregTheGreek) commented at [2024-05-31 20:10](https://github.com/ethereum/solidity/issues/597#issuecomment-2142914676):

Would it not be potentially dangerous to let the base storage offset be user set? I feel like the base should always be the keccak hash of the contract code, then afterwards let users set storage variable within that context eg: `base.someStruct` `base.outerMapping.innerMapping`

#### <img src="https://avatars.githubusercontent.com/u/4210206?v=4" width="50">[nlordell](https://github.com/nlordell) commented at [2024-06-01 06:59](https://github.com/ethereum/solidity/issues/597#issuecomment-2143331954):

> I feel like the base should always be the keccak hash of the contract code

One issue with that is upgrading contracts that inherit the same storage layout becomes very difficult.

#### <img src="https://avatars.githubusercontent.com/u/2896048?u=50e53ac7c29c28cc4ed55ff0e65d66d7c9c39cf2&v=4" width="50">[rmeissner](https://github.com/rmeissner) commented at [2024-06-03 08:56](https://github.com/ethereum/solidity/issues/597#issuecomment-2144655357):

I agree with @nlordell here. I.e. for Safe we would like that all versions of the Safe share their storage layout, with the proposal to make this dependant on the bytecode this would not work out of the box.

Also making the offset more explicit to set make more sense for me then doing some implicit enforcement. As we do not enforce this on EVM level it will always be possible to work around the compiler. 

Imo it would also be nice to have some alignment on the pattern for this with the Vyper team. 

Note: personally I am a fan of a compiler flag for this.

#### <img src="https://avatars.githubusercontent.com/u/1347491?v=4" width="50">[ekpyron](https://github.com/ekpyron) commented at [2024-06-03 11:01](https://github.com/ethereum/solidity/issues/597#issuecomment-2144906376):

> Decoupling storage location from inheritance linearization is important. What is the main challenge to going in that direction rather than just adding a global offset?

@frangio Generally decoupling storage from inheritance linearization is definitely something we'd want to do longer-term - so far the plan was to only do this in the next iteration of Solidity while simultaneously replacing inheritance itself with generic arguments that can be used to compose functionality, but that's a much larger change that so far is only planned with introducing "experimental Solidity" that will have generics in the first place, which will take longer than needed for 7702.

I'd be open to entertaining the idea sooner than that and to e.g. promote something like https://eips.ethereum.org/EIPS/eip-7201 to get proper language support, but in particular in the context of EIP 7702, the main concern with that is the following:

If we have independent implementations acting on the same storage, using globally fixed storage locations for them a la 7201 will mean that, if you use the same library/base contract with namespaced storage in more than one of these implementations, they'll still share the same location in storage, which may lead to issues. In that sense, a global offset for the most derived contract addresses the issue of wanting to have independent storage for independent implementations for 7702 more directly (of course, you can still use https://eips.ethereum.org/EIPS/eip-7201 nonetheless, which will still require care in this setting).

But we're very open to more opinions on the matter.

#### <img src="https://avatars.githubusercontent.com/u/176499?u=727c007c0698f1632e98401987d52b129fcf1474&v=4" width="50">[alcuadrado](https://github.com/alcuadrado) commented at [2024-06-03 14:16](https://github.com/ethereum/solidity/issues/597#issuecomment-2145319926):

> @frangio Generally decoupling storage from inheritance linearization is definitely something we'd want to do longer-term - so far the plan was to only do this in the next iteration of Solidity while simultaneously replacing inheritance itself with generic arguments that can be used to compose functionality, but that's a much larger change that so far is only planned with introducing "experimental Solidity" that will have generics in the first place, which will take longer than needed for 7702.

Have you considered doing this outside of the language? For example, as a setting to the compiler. e.g. you could provide a storage layout (like the one the compiler outputs), for the compiler to use it instead of the default logic.

Adding it to the language sounds like the most correct approach but also the most costly.

#### <img src="https://avatars.githubusercontent.com/u/1347491?v=4" width="50">[ekpyron](https://github.com/ekpyron) commented at [2024-06-03 14:33](https://github.com/ethereum/solidity/issues/597#issuecomment-2145363247):

I'd be hesitant about not making this explicit in the sources. Just as an example of an issue with that: It would be easy to have innocuously looking sources that look perfectly safe, but provide a storage layout with it that allows for collisions and is exploitable.

#### <img src="https://avatars.githubusercontent.com/u/481465?v=4" width="50">[frangio](https://github.com/frangio) commented at [2024-06-03 14:35](https://github.com/ethereum/solidity/issues/597#issuecomment-2145367134):

> if you use the same library/base contract with namespaced storage in more than one of these implementations, they'll still share the same location in storage, which may lead to issues

Yes this is a reasonable concern that is hard to resolve. In some cases this may be fine, in others it may not.

My proposal for concrete syntax is to reuse the  `pragma` statements but placed inside the contract.

```solidity
contract Bar is Foo {
  pragma storageoffset * <pure_expr>;
}
```

The asterisk is because I think this syntax could also be used to specify offsets more granularly, disregarding linearization:

```solidity
contract Bar is Foo {
  pragma storageoffset Foo <pure_expr>;
  pragma storageoffset Bar <pure_expr>;
}
```

If implementing this granularly increases complexity significantly, I agree it would be useful to release the global setting as a first step. Granular overrides can be added as a follow-up.

#### <img src="https://avatars.githubusercontent.com/u/176499?u=727c007c0698f1632e98401987d52b129fcf1474&v=4" width="50">[alcuadrado](https://github.com/alcuadrado) commented at [2024-06-03 14:35](https://github.com/ethereum/solidity/issues/597#issuecomment-2145368305):

> I'd be hesitant about not making this explicit in the sources. Just as an example of an issue with that: It would be easy to have innocuously looking sources that look perfectly safe, but provide a storage layout with it that allows for collisions and is exploitable.

good point

#### <img src="https://avatars.githubusercontent.com/u/1347491?v=4" width="50">[ekpyron](https://github.com/ekpyron) commented at [2024-06-03 15:44](https://github.com/ethereum/solidity/issues/597#issuecomment-2145548794):

> > if you use the same library/base contract with namespaced storage in more than one of these implementations, they'll still share the same location in storage, which may lead to issues
> 
> Yes this is a reasonable concern that is hard to resolve. In some cases this may be fine, in others it may not.
> 
> My proposal for concrete syntax is to reuse the `pragma` statements but placed inside the contract.
> 
> ```solidity
> contract Bar is Foo {
>   pragma storageoffset * <pure_expr>;
> }
> ```
> 
> The asterisk is because I think this syntax could also be used to specify offsets more granularly, disregarding linearization:
> 
> ```solidity
> contract Bar is Foo {
>   pragma storageoffset Foo <pure_expr>;
>   pragma storageoffset Bar <pure_expr>;
> }
> ```
> 
> If implementing this granularly increases complexity significantly, I agree it would be useful to release the global setting as a first step. Granular overrides can be added as a follow-up.

The question is then: what happens if ``Foo`` also specifies a storage offset? Well, you're calling it ``offset``, so I guess they are meant to just add up? That'd require some reasoning about its safety... So far, I had an absolute base location in mind, but thinking about it as a cumulative offset may be interesting (resp. a even a nested hashing structure). Most flexible for combining hashes would probably be to have a pure ``Foo.storageoffset`` (or ``type(Foo).storageoffset`` or similar) that can be used in the pure expression for custom combination (but otherwise override the storage base and thus maybe better call it ``storagebase`` than offset to avoid confusion).

In my mind, syntactically, this is best attached to the contract definition (outside the brackets), since at least if it's thought of as a global storage base for the entire inheritance hierarchy, it strikes me as a property of the (as first step most derived) contract. Or would you want to be able to switch to different offsets within the same contract? Then fully replacing the previous one? But yeah, I'm still on the fence on syntax myself so far.

But yeah, I think a good strategy would be to only allow one specification in the most-derived contract as a first step and then subsequently think through more complex ways of combining with base contract specifications. But the syntax should allow for appropriate extensions like that, the asterisk is an interesting option in that regard. The general case would involve things like mixtures of unspecified storage bases for some base contracts, while specified storage bases for others and would need clear overriding properties, etc.

Syntactically, I'm myself not keen on using ``pragma`` as non-top-level construct with this kind of semantics, but a simple ``storagebase`` should suffice, the main question is where and how to attach it exactly, s.t. it works for the simple case and is sufficiently extensible.

#### <img src="https://avatars.githubusercontent.com/u/4210206?v=4" width="50">[nlordell](https://github.com/nlordell) commented at [2024-06-03 19:43](https://github.com/ethereum/solidity/issues/597#issuecomment-2145983353):

> The question is then: what happens if Foo also specifies a storage offset?

You could make it so contracts that specify an offset are no longer inheritable (like `sealed` in other languages).

#### <img src="https://avatars.githubusercontent.com/u/481465?v=4" width="50">[frangio](https://github.com/frangio) commented at [2024-06-04 00:15](https://github.com/ethereum/solidity/issues/597#issuecomment-2146336186):

> you're calling it `offset`, so I guess they are meant to just add up?

No that's not what I meant. I meant "offset from 0" in all cases. We could call it "base" or some other term.

#### <img src="https://avatars.githubusercontent.com/u/1347491?v=4" width="50">[ekpyron](https://github.com/ekpyron) commented at [2024-06-04 14:42](https://github.com/ethereum/solidity/issues/597#issuecomment-2147717921):

> > The question is then: what happens if Foo also specifies a storage offset?
> 
> You could make it so contracts that specify an offset are no longer inheritable (like `sealed` in other languages).

Yes, at least as a first iteration of this.

#### <img src="https://avatars.githubusercontent.com/u/16929357?u=a148cf5f5bd8d1324a1044cc1bd38c6b6e1c74f1&v=4" width="50">[GregTheGreek](https://github.com/GregTheGreek) commented at [2024-06-08 16:10](https://github.com/ethereum/solidity/issues/597#issuecomment-2156089756):

Didn't think of the upgrade issue. Without some global lock then we still run into the issue that we might have previous state corrupted (or rather modified) unexpectedly. Not saying its a blocker just makes for weird edge cases. 


> You could make it so contracts that specify an offset are no longer inheritable (like sealed in other languages).


How would that work for upgrading contracts? If Safe sealed a bunch of parameters and upgraded it would those be useable again?

#### <img src="https://avatars.githubusercontent.com/u/4210206?v=4" width="50">[nlordell](https://github.com/nlordell) commented at [2024-06-10 08:28](https://github.com/ethereum/solidity/issues/597#issuecomment-2157696239):

> How would that work for upgrading contracts? If Safe sealed a bunch of parameters and upgraded it would those be useable again?

I'm not sure I understand your point. In my mind (obv. with imaginary syntax):

```solidity
contract Safe {
    // ... business as usual ...
}

sealed{storageoffset: keccak256("Safe7712")} contract Safe7712 is Safe {}
```

This would:
- define generate bytecode for a `Safe7712` contract
- you cannot do `contract SomeOtherThing is Safe7712`, you would have to explicitly inherit from `Safe` and set a storage offset.
- If the Safe contract changes, then things continue to work - the compiler would build a new `Safe7712` with the updates and the same storage offset. The assumption is that `Safe` is responsible for managing storage migration on new version exactly as it is today.

#### <img src="https://avatars.githubusercontent.com/u/1347491?v=4" width="50">[ekpyron](https://github.com/ekpyron) commented at [2024-06-10 15:33](https://github.com/ethereum/solidity/issues/597#issuecomment-2158673576):

An alternative, maybe more complex, approach we've been wondering about would be to already move further towards generally decoupling storage from C3 linearization.

In particular, the idea is based on the fact that conceptually the https://eips.ethereum.org/EIPS/eip-7201 pattern could be adjusted to

```solidity
abstract contract Example {
    struct MainStorage {
        uint256 x;
        uint256 y;
    }

    function _getExampleMainStorage() internal virtual view returns (MainStorage storage);

    function _getXTimesY() internal view returns (uint256) {
        MainStorage storage $ = _getMainStorage();
        return $.x * $.y;
    }
}

contract FinalContract is Example {
    // keccak256(abi.encode(uint256(keccak256("example.main")) - 1)) & ~bytes32(uint256(0xff));
    bytes32 private constant EXAMPLE_MAIN_STORAGE_LOCATION =
        0x183a6125c38840424c4a85fa12bab2ab606c4b6d0e7cc73c0c06ba5300eab500;

    function _getExampleMainStorage() internal override view returns (MainStorage storage $) {
        assembly {
            $.slot := EXAMPLE_MAIN_STORAGE_LOCATION
        }
    }
}
```

Now we're not suggesting to do just that, since it has the same issues of the compiler being oblivious to the actual storage layout.
But, minimally, that could be alleviated by allowing explicit storage locations to be specified *only in the most derived contract* and *only if no base contracts have any storage variables*, as in:

```solidity
contract FinalContract is Example {
    storage{slot: keccak256(abi.encode(uint256(keccak256("example.main")) - 1)) & ~bytes32(uint256(0xff))}
    Example.MainStorage exampleStorage;

    function _getExampleMainStorage() internal override view returns (MainStorage storage) {
        return exampleStorage;
    }
}
```

However, having to access storage via indirection of internal functions is still generally inconvenient, but the concept could be further turned into compiler-builtin mechansisms by introducing `virtual` storage variables. As in:

```solidity
abstract contract ExampleA {
    struct MainStorage {
        uint256 x;
        uint256 y;
    }
    // A virtual storage variable does *not* get a storage location itself directly.
    // It forces the contract to become `abstract` and requires an override
    // providing the actual location in the most-derived contract
    MainStorage virtual $;

    function _getXTimesY() internal view returns (uint256) {
        return $.x * $.y;
    }
}
// Alternatively even:
abstract contract ExampleB {
    uint256 virtual x;
    uint256 virtual y;

    function _getXTimesY() internal view returns (uint256) {
        return x + y;
    }
}

```

In turn, we could allow and require the most-derived (and - at least for now - *only* the most derived contract) to "override" the inherited state variables, providing them with a particular location, while allowing to specify explicit storage locations. As in:

```solidity
function erc7201_slot(string memory _id) pure returns (bytes32) {
    return keccak256(abi.encode(uint256(keccak256(_id)) - 1)) & ~bytes32(uint256(0xff));
}
contract FinalContractA is ExampleA {
    storage{ slot: erc7201_slot("example.main") }
    MainStorage override ExampleA.$;
}
// or in the alternative version:
contract FinalContractB is ExampleB {
    storage{ slot: erc7201_slot("example.main") }
    uint256 override ExampleB.x;
    uint256 override ExampleB.y; // would be laid out after `Example.x` following the usual rules
}
```

To make this safer, the logic could be that if *any* inherited state variable is `virtual`, *all* of them have to be virtual (except in the most-derived contract) and that explicit storage slot specifiers are only allowed if *all* inherited state variables are `virtual`.

However, this would mean that each and every state variable would have to be laid out explicitly in the most derived contract, which may be overly verbose.

Conversely, we could consider doing something similar on the contract-level instead of the level of state variables, along the lines of
```solidity
contract FinalContractB2 is ExampleB {
    storage{ slot: erc7201_slot("example.main") }
    storage(ExampleB) override; // good syntax is a bit tricky here, though
    /// storage ExampleB.* override; // there may be better options or variants syntactically
    // TODO: what about bases of bases?
}
```

This would lead to something similar as already suggested: contracts could declare their entire storage "virtual" (pending syntax - whether reusing `virtual` is a good choice is debatable, especially for an entire contract), and the most derived contract could explicitly lay out storage for each base contract (that has any state variables). That'd be close to @frangio's proposal in https://github.com/ethereum/solidity/issues/597#issuecomment-2145367134 (modulo syntax and some restrictions, e.g. that base contracts are required to be explicit about deferring the storage layout, which in turn forces the derived contract to specify the locations).
However, the issue there is: what to do about base contracts that themselves inherit state variables? Especially since the C3-linearization of the base contract is not a good basis in multi-inheritance settings. Some options here:
- Specifying an entire contract's storage in bulk could only be allowed if that contract doesn't itself inherit state variables - or if its C3-linearization occurs linearly in the C3-linearization of the most-derived contract - but then the rules are quickly getting complicated there.
- Simpler may be: specifying storage for a base contract only extends to the storage of that contract itself, not its own bases. So specifying the location for a base contract, requires also specifying the locations for all its bases (that have state variables). (So specifying storage for a base contract in the most derived contract is literally just shorthand for listing/overriding its own state variables in order.)
- For the simplest case there could be, as suggested before, catch-all syntax for the entire C3 linearization of the most-derived contract (while still requiring all storage in the bases to be explicitly `virtual` or similar)

**So, in particular, we're wondering about more opinions on the following:**
- Is finer-grained control over the layout (as in per-state-variable instead of per-contract) desirable?
- Should we require a state variable in a base contract - or the base contract itself - to explicitly state that the storage locations are to be defined elsewhere (by use of `virtual` or similar) to avoid incorrect assumptions on that contract's storage layout in isolation (not too big of a danger, since inheritance will potentially move state variables anyways), but more importantly to *force* to specify explicit locations in the derived contract?
- Would you consider having to lay out the entirety of storage in a most-derived contract a feature in the sense that it makes the layout unquestionably explicit, or a burden due to its necessary verbosity compared to a global base storage position for the entire C3 linearization? Especially if done per state-variable, but also if just done per base-contract (probably then requiring to also do it for bases-of-bases if they have state variables)?

#### <img src="https://avatars.githubusercontent.com/u/481465?v=4" width="50">[frangio](https://github.com/frangio) commented at [2024-06-10 16:38](https://github.com/ethereum/solidity/issues/597#issuecomment-2158839570):

> Is finer-grained control over the layout (as in per-state-variable instead of per-contract) desirable?

Yes it is desirable to declare a variable and specify where it should be placed in storage. [ERC-1967](https://ercs.ethereum.org/ERCS/erc-1967) is the simplest example where this would be used.

Ideally the compiler should be able to check for clashes though, and I don't know if this is possible in the general case. It is possible if you restrict to locations of the form of ERC-1967 (for single-slot values) or ERC-7201, and I think these are general enough for EIP-7702 purposes, but there are other conventions that people might want to use.

One point about per-state-variable control of layout is that it should not be applicable to `private` state variables, so it is not sufficient as a mechanism in itself.



> to avoid incorrect assumptions on that contract's storage layout in isolation (not too big of a danger, since inheritance will potentially move state variables anyways)

I agree on the comment in parentheses. This incorrect assumption should not be a motivation for any changes.



> Should we require a state variable in a base contract - or the base contract itself - to explicitly state that the storage locations are to be defined elsewhere (by use of virtual or similar) [...] to _force_ to specify explicit locations in the derived contract

Should `virtual` storage variables be available? Sure, I can see how they might be useful. Should they be a prerequisite to be able to override the storage location of base contracts? Probably not. I think the use case for EIP-7702 is to take a contract off the shelf and deploy it at a storage offset other than 0, and I think this should not require changes to the base contract source code.


> or a burden due to its necessary verbosity compared to a global base storage position for the entire C3 linearization? 

I would consider it a burden but because it leaks implementation details of base contracts. Authors of reusable contracts should be able to ship changes to their code, including to storage variables, without breaking downstream code!



> also if just done per base-contract (probably then requiring to also do it for bases-of-bases if they have state variables)

This also leaks implementation details (especially bases-of-bases), although it is something library authors may already be familiar with (via forced override in functions, see [_Thoughts on override(A, B) syntax_](https://forum.soliditylang.org/t/thoughts-on-override-a-b-syntax/767)).

---



> * Specifying an entire contract's storage in bulk could only be allowed if that contract doesn't itself inherit state variables - or if its C3-linearization occurs linearly in the C3-linearization of the most-derived contract - but then the rules are quickly getting complicated there.

Not sure if this is what you meant by "occurs linearly" but it may be intuitive to say that if a base contract and its own base contracts form an independent subtree in the inheritance DAG (i.e., there are no edges into this subtree other than to its root) it should be possible to remove it from storage linearization and put it elsewhere in storage.

You could refine this further by saying that you only consider contracts that have linear/non-relocated storage. I've written too much at this point but I can elaborate later if this sounds interesting.

#### <img src="https://avatars.githubusercontent.com/u/1347491?v=4" width="50">[ekpyron](https://github.com/ekpyron) commented at [2024-06-11 11:13](https://github.com/ethereum/solidity/issues/597#issuecomment-2160481444):

Yeah, I definitely understand the desire of not leaking implementation details - there is some friction, though, between having 1. fine-grained control over individual state variables, 2. safely ensuring that all state variables are at "safe" locations and 3. hiding implementation details. E.g. if two bases, which are supposed to be located at distinct storage areas, add a shared base with a state variable (as an implementation detail), I don't see a choice other than being explicit about the location of that shared base (resp. its state variables) similarly to the existing disliked override logic for virtual functions (or just disallowing the relocation in that case). Similarly, relocating individual state variables while keeping others private may be dangerous - there may be sane solutions to this (just as an example, relocation of specific storage variables could only be allowed if simultaneously being explicit about the storage location of the containing structure, i.e. contract or inheritance subtree).

However, we don't need to fully solve this for an initial version that allows for EIP-7702 safety (for which relocating the entire inheritance graph in bulk in (only) the most-derived contract should be enough initially), so for the time being this is mainly a concern for ensuring that our method/syntax ideally remains future-proof.

>  I think the use case for EIP-7702 is to take a contract off the shelf and deploy it at a storage offset other than 0, and I think this should not require changes to the base contract source code.

Here the main question is whether we should make this a hard requirement or whether the expectation is rather to ship explicitly adjusted EIP-7702-versions of contracts. I'd assume that for use in the context of 7702 contract code would need to be at least reinspected (e.g. against potential clashes due to storage use via inline assembly, resp. the 7201 pattern) in any case - however, if there is a strong desire to be able to use fully unmodified base contracts that are merely relocated via inheritance, we can take that into account.

>  if a base contract and its own base contracts form an independent subtree in the inheritance DAG

It's clear what you mean there and yes, under that condition relocating a full subtree is safe.

So for the time being, I'd summarize our state of discussion as follows:
- We should allow relocating the entirety of storage of a most-derived contract (including inherited state variables) *now* (i.e. at the latest in time for Prague) for initial EIP-7702-safety.
- Ideally, we should have a method that can be extended to also allow specifically relocating particular bases or inheritance subtrees in the future.
- Ideally, the latter method is robust against changes in implementation details as much as safely possible.
- Ideally, a further extension should allow for even finer-grained control over the locations of specific state variables.
- Potentially, the method should allow for simply reusing existing contracts and merely relocating them e.g. via inheritance

#### <img src="https://avatars.githubusercontent.com/u/8608880?u=030afb7a85282ab842fb4c2c7aab34ee1c055e2f&v=4" width="50">[Zer0dot](https://github.com/Zer0dot) commented at [2024-06-11 14:41](https://github.com/ethereum/solidity/issues/597#issuecomment-2160942785):

Hey all, I'm not sure how wildly incorrect I might be (fairly new to this part of ethdev), but I guess it's worth floating this idea I had, although it breaks account storage persisting through different code delegations. Let me know if that's an issue.

Would it be possible to slightly modify what SLOAD/SSTORE does for accounts with set code (7702), such that instead of affecting slot X for the account, it affects slot x for a fictional account at address bytes20(uint160(keccak256(account . 7702_address_field)))?

This way, we maintain the benefit that contracts don't need to be rewritten with namespaced storage, and app devs don‚Äôt have to worry about it. All the while maintaining guarantees that whatever contract a user delegates control to won't have any storage collisions regardless of how other contracts the user may have delegated to managed storage (i.e. you don't have to be aware of previous contracts' potential messups or users accidentally corrupting their storage).

#### <img src="https://avatars.githubusercontent.com/u/4210206?v=4" width="50">[nlordell](https://github.com/nlordell) commented at [2024-06-14 11:47](https://github.com/ethereum/solidity/issues/597#issuecomment-2167852824):

> Would you consider having to lay out the entirety of storage in a most-derived contract a feature in the sense that it makes the layout unquestionably explicit, or a burden due to its necessary verbosity compared to a global base storage position for the entire C3 linearization?

I think there are pros and cons to both ways of implementing it:

- global base storage position: means that existing contracts in commonly used libraries can also use this feature without having to change each slot in each contract to be `virtual` (which could cause a lot of code to change everywhere).
- lay out the entirety of storage in a most-derived contract: This is the most expressive of the two options (as you can have arbitrary layouts and are not limited to allocating storage slots from a specific offset like in the other example). You could also argue that the number of contracts that want to make use of this feature, and the number of storage slots that want to make use of this feature is low enough that it will not cause a large cascade of code changes.

The global storage position feels "easier", but it also feels a bit more like a temporary solution to a very specific usecase rather than an end goal, which makes the engineer in me feel icky.

#### <img src="https://avatars.githubusercontent.com/u/95942363?u=2b812d1148fbcab6c291e16fd8eaeacabf79bac4&v=4" width="50">[zerosnacks](https://github.com/zerosnacks) commented at [2024-07-03 07:39](https://github.com/ethereum/solidity/issues/597#issuecomment-2205307372):

Given that ERC-7201 is now well defined, in the `standards` track and has accessible resources on it (https://www.rareskills.io/post/erc-7201), developers expect that their tooling has support for it. It would be great if this could be added as part of the artifacts generated by the compiler. 

Ref: https://github.com/foundry-rs/foundry/issues/7662

#### <img src="https://avatars.githubusercontent.com/u/137030?v=4" width="50">[cameel](https://github.com/cameel) commented at [2024-07-10 15:22](https://github.com/ethereum/solidity/issues/597#issuecomment-2220808904):

Thank you everyone for the input so far. Looks like we have more clarity on the possible use cases so it's time to start moving things forward on getting the syntax finalized. The biggest obstacle here is still choosing something that will be easy to extend in the right direction without making contract definitions misleading, unreadable or too repetitive. We discussed it at length and all the options so far have drawbacks. Since we need to decide something anyway, here's my proposal that I wanted to put up as a more concrete basis for further discussion:

https://notes.ethereum.org/@solidity/explicit-storage-layout-syntax

This is by no means final, but I think it reconciles our own concerns with many of the requirements posted here so far. Not all of them could be incorporated though and we're still open to alternative proposals or amendments.

The proposal presents 3 variants, with the first one being only just enough to cover EIP-7702 and the other two trying to accommodate other use cases. Note that in either case we'd only implement enough to allow specifying the location for the most derived contract, which would basically be this, respectively:

1.  ```solidity
    contract C at <location> {}
    ```
1.  ```solidity
    contract C layout at <location> {}
    ```
1.  ```solidity
    contract C { layout at <location>; }
    ```

#### <img src="https://avatars.githubusercontent.com/u/4210206?v=4" width="50">[nlordell](https://github.com/nlordell) commented at [2024-07-10 15:29](https://github.com/ethereum/solidity/issues/597#issuecomment-2220828731):

_(I don't know if it is intentional or not, but I don't have access to the notes you linked)_

**Edit**: Works now üôå.

#### <img src="https://avatars.githubusercontent.com/u/1347491?v=4" width="50">[ekpyron](https://github.com/ekpyron) commented at [2024-07-10 15:44](https://github.com/ethereum/solidity/issues/597#issuecomment-2220873064):

> _(I don't know if it is intentional or not, but I don't have access to the notes you linked)_

Should work now

#### <img src="https://avatars.githubusercontent.com/u/481465?v=4" width="50">[frangio](https://github.com/frangio) commented at [2024-07-10 22:36](https://github.com/ethereum/solidity/issues/597#issuecomment-2221642488):

Thanks for sharing the proposal! I like variant 3, specifically layout blocks, but `layout at` as a shorthand seems fine too.

What do you think is the subset that should be implemented initially?

One thing that I see listed as a potential requirement (great summary, by the way) but not addressed in the proposals is the issue of collisions. Ideally the compiler would be able to guarantee that a layout is collision-free. I don't think this can be done for arbitrary expressions, but it should be possible if restricted to known formulas, e.g. native Solidity formulas for arrays and mappings, or ERC-7201. Constants pose a problem because they could be hash outputs. Do others agree that this is an important requirement?

#### <img src="https://avatars.githubusercontent.com/u/4396533?u=f2d0be7c169871f163e9ae53499a0023bedcb8e5&v=4" width="50">[sakulstra](https://github.com/sakulstra) commented at [2024-07-11 08:28](https://github.com/ethereum/solidity/issues/597#issuecomment-2222337385):

I think collision detection would be quite valuable.

It's not clear to me why 1) would not support `ERC-7201`?
Shouldn't:
```
contract FinalContract
    at keccak256(abi.encode(uint256(keccak256("FinalContract")) - 1)) & ~bytes32(uint256(0xff))
    is BaseA, BaseB
{
```
be exactly enough to conform to 7201? Could someone elaborate?

#### <img src="https://avatars.githubusercontent.com/u/481465?v=4" width="50">[frangio](https://github.com/frangio) commented at [2024-07-11 14:44](https://github.com/ethereum/solidity/issues/597#issuecomment-2223127442):

All of the variants support ERC-7201 but also support other expressions and that's one way that collisions could come in. But I don't think we'd want to restrict to ERC-7201 only, for example there is ERC-1967, and there may be other schemes people want to use.

That said this is something that was considered in ERC-7201 for the design of the annotation, whose format is `@custom:storage-location <FORMULA_ID>:<NAMESPACE_ID>` where `FORMULA_ID` can be `erc7201` or something else.

#### <img src="https://avatars.githubusercontent.com/u/137030?v=4" width="50">[cameel](https://github.com/cameel) commented at [2024-07-11 19:41](https://github.com/ethereum/solidity/issues/597#issuecomment-2223739350):

> What do you think is the subset that should be implemented initially?

Just specifying the location for the whole hierachy.

If you mean beyond that, then as @ekpyron said above, the next step would be to allow relocating specific base contracts or subtrees. But how quickly we proceed with that strongly depends on how certain we feel that this design is robust and extensible enough. For now we need anyone interested to try to poke holes in it and bring up stuff that we may be overlooking :)

> Ideally the compiler would be able to guarantee that a layout is collision-free.

TBH we assumed that people would actually be pushing for *more* expressivity here rather than for restricting it. This is exactly the kind of feedback we need here :)

This is something we could consider if there's clear consensus that this is what everyone wants, but for now it seems to me like it might be a bit too restrictive. I'd be worried about missing some common formulas from pre-ERC-7201 schemes being in active use.

So far we were not planning to enshrine any particular method of selecting locations, rather leaving that up to ERCs/conventions/libraries. The idea was to allow any expression that can be evaluated at compilation time (as long as the resulting locations don't overlap in an obvious way within a single contract hierarchy). Currently that set is pretty limited, but still includes constants. With time it would be extended to include enough things to cover ERC-7201 (keccak, conversions, some subset of ABI encoding), and eventually we'd get full compile-time evaluation support (but that might only ship on top of the new type system). With that, common formulas for locations could be considered for inclusion in the standard library.

> It's not clear to me why 1) would not support `ERC-7201`?

Because it will relocate the whole inheritance hierarchy, including `BaseA` and `BaseB` not just `FinalContract`. While ERC-7201 does not mention inheritance at all, it seems to me that part of the motivation behind it was to give the contract a storage location completely independent of inheritance hierarchy. So if you do happen to inherit from a contract that follows ERC-7201, its storage should not impact yours in any way. Variant 1) does not let you do that. You could say it technically works if you do not use inheritance, but if you do use it, storage of all contracts in the hierarchy is still coupled.

#### <img src="https://avatars.githubusercontent.com/u/137030?v=4" width="50">[cameel](https://github.com/cameel) commented at [2024-07-17 18:20](https://github.com/ethereum/solidity/issues/597#issuecomment-2233963011):

@frangio We discussed the idea of limiting the available expressions on the design call today, but so far we're not really convinced this is something that should be enforced by the compiler. We're open to being convinced otherwise, but for now we'd still rather leave that up to convention.

Guaranteeing safety against collisions may be hard to reconcile with allowing more than one scheme and we really don't want to limit this feature to a single convention, even if it's ERC-7201. Also, this would have to work nicely not only with the current scheme used by the compiler but also the future one, which is likely to be introduced in response to Verkle Trees. The current scheme will need to change in certain ways because Verkle will make not colocating data together (as is the case for dynamic types now) more expensive.

---

I also updated the proposal to address your comments there. I removed the override from the ERC-7201 example. In place of an annotation I added a `erc7201()` function, which could potentially end up in stdlib in the future (meant to be evaluated at compilation time). I also updated the detailed rules with what I already said here about allowed expressions and collision prevention.

#### <img src="https://avatars.githubusercontent.com/u/137030?v=4" width="50">[cameel](https://github.com/cameel) commented at [2024-09-19 11:39](https://github.com/ethereum/solidity/issues/597#issuecomment-2360751419):

We decided to go with variant 2. Here's the spec for what exactly will be implemented: [Initial syntax for explicit storage locations](https://notes.ethereum.org/@solidity/explicit-storage-locations-initial-syntax). As I said before, it's just the minimal version of it, though we did include a compile-time helper for the ERC-7201 formula to nudge people towards using the established conventions rather than arbitrary expressions.

This is the new syntax in a nutshell:
```solidity
contract C layout at 0x1234 {}
```
```solidity
contract FinalContract
    layout at erc7201("FinalContract")
    is BaseA, BaseB
{}
```

From the feedback we got here so far, it seems to me that it should be a generally acceptable base to extend later as needed. We're planning to start working on it after we're done with some other features which have kept us busy so far. If anyone has some reservations and can provide strong arguments for why this may be bad or insufficient, this is the moment to speak up.


-------------------------------------------------------------------------------



[Export of Github issue for [ethereum/solidity](https://github.com/ethereum/solidity). Generated on 2024.12.15 at 06:45:24.]
