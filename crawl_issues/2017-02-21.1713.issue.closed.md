# [\#1713 Issue](https://github.com/ethereum/solidity/issues/1713) `closed`: Tracing of a contract using srcmap gives mappings with type "i" but without following opcodes from any function

#### <img src="https://avatars.githubusercontent.com/u/700837?v=4" width="50">[asinyagin](https://github.com/asinyagin) opened issue at [2017-02-21 10:54](https://github.com/ethereum/solidity/issues/1713):

Hi,

When I call `createTierBaseFor()` from the following contract:
```
pragma solidity ^0.4.0;

contract Contract1 {
  struct tierEntry {
    string description; // "standard rates"
  }

  function createTierBaseFor(string currency, address banker) {
    setTierPercentages(0,currency,1,2,3,4,5,"base rates");
  }

  function setTierPercentages(uint16 tier, string currency, uint256 buy,
                              uint256  sell,uint256  weBuy,uint256  weSell,
                              uint256 storeFee,string rateName) 
  {
    tierEntry memory te;
    log0("asdf");
  }
}
```
I'm getting this trace: https://gist.github.com/asinyagin/7be3252a95ae29daa51924a04a961acd

On line [126](https://gist.github.com/asinyagin/7be3252a95ae29daa51924a04a961acd#file-gistfile1-txt-L126) I get a jump to `setTierPercentages`
```
pc: 481,	opcode: JUMP,	address: 0x17956ba5f4291844bc25aedb27e69bc11b5bda39,	mapping: {"source":0,"line":8,"column":4,"type":"i"}, 	func: Contract1.createTierBaseFor(string memory,address)
```
The [next](https://gist.github.com/asinyagin/7be3252a95ae29daa51924a04a961acd#file-gistfile1-txt-L127) opcode is in `setTierPercentages`:
```
pc: 487,	opcode: JUMPDEST,	address: 0x17956ba5f4291844bc25aedb27e69bc11b5bda39,	mapping: {"source":0,"line":11,"column":2,"type":"-"}, 	func: Contract1.setTierPercentages(uint16,string memory,uint256,uint256,uint256,uint256,uint256,string memory)
```

But after it I get mappings with type `i` without entering to any function at lines [130](https://gist.github.com/asinyagin/7be3252a95ae29daa51924a04a961acd#file-gistfile1-txt-L130), [143](https://gist.github.com/asinyagin/7be3252a95ae29daa51924a04a961acd#file-gistfile1-txt-L143). And two `o`'s at lines [159](https://gist.github.com/asinyagin/7be3252a95ae29daa51924a04a961acd#file-gistfile1-txt-L159), [165](https://gist.github.com/asinyagin/7be3252a95ae29daa51924a04a961acd#file-gistfile1-txt-L165).

These seem to be wrong mappings. I think there should be following mappings to some function or no mappings with type `i`.

```
root@4a541893579d:~/ethereum-sandbox# solc --version
solc, the solidity compiler commandline interface
Version: 0.4.9+commit.364da425.Linux.g++
```

#### <img src="https://avatars.githubusercontent.com/u/700837?v=4" width="50">[asinyagin](https://github.com/asinyagin) commented at [2017-02-21 11:28](https://github.com/ethereum/solidity/issues/1713#issuecomment-281317051):

I've updated the trace gist.

#### <img src="https://avatars.githubusercontent.com/u/9073706?v=4" width="50">[chriseth](https://github.com/chriseth) commented at [2017-02-22 14:32](https://github.com/ethereum/solidity/issues/1713#issuecomment-281685299):

I'm not sure, but "jump in" does not necessarily mean that it jumps into a solidity-level function, it just means that it will be followed by a respective "jump out" later and the return address is on the stack. I believe that these jumps are generated by the initialization routines for the memory struct which were moved to an assembly-level function recently.

#### <img src="https://avatars.githubusercontent.com/u/700837?v=4" width="50">[asinyagin](https://github.com/asinyagin) commented at [2017-02-22 15:04](https://github.com/ethereum/solidity/issues/1713#issuecomment-281694737):

@chriseth got it. So that's a correct behavior, right?

#### <img src="https://avatars.githubusercontent.com/u/5822633?u=61e06090743a58b3a57713075963b115edae488e&v=4" width="50">[romanman](https://github.com/romanman) commented at [2017-02-22 15:05](https://github.com/ethereum/solidity/issues/1713#issuecomment-281694860):

@chriseth 

1. Do we have deterministic way to 100% be sure that we are entering
 the function? The thing is that our debugger should rely on something.

#### <img src="https://avatars.githubusercontent.com/u/9073706?v=4" width="50">[chriseth](https://github.com/chriseth) commented at [2017-02-22 15:10](https://github.com/ethereum/solidity/issues/1713#issuecomment-281696456):

Yes, it's correct behaviour. I don't think there is a 100% correct way to distinguish a recursive call from a library call, although I am pretty sure that if you reach a jumpdest whose source location is the whole function (i.e. this is the function entry point) and then you have another "jump in" without the source location changing, it cannot be a recursive call, but will be a call to an assembly function instead.


-------------------------------------------------------------------------------



[Export of Github issue for [ethereum/solidity](https://github.com/ethereum/solidity). Generated on 2024.12.15 at 06:45:24.]
