# [\#3449 Issue](https://github.com/ethereum/solidity/issues/3449) `closed`: Dynamic / Runtime Inheritance
**Labels**: `waiting for more input`, `language design :rage4:`, `closed due inactivity`, `stale`


#### <img src="https://avatars.githubusercontent.com/u/9434715?u=66d3c1845462fc37b63fa8d6e4e62e1ede0ea4ab&v=4" width="50">[hyperfekt](https://github.com/hyperfekt) opened issue at [2018-01-29 20:16](https://github.com/ethereum/solidity/issues/3449):

With more complex applications being built with Solidity, the need for more flexibility in how contracts are created arises and will over time become pressing.
Currently the only way to have a contract C create a new contract N1is to either include all of N1's bytecode in C, or to copy an already deployed contract N0. In both cases, the entirety of the contract is copied.
A problem emerges when there exist _independent_ variations on N (called Na, Nb, ...) which are to be combined into one contract Nabc...
This means that every version of N has to be provided to C as a whole, resulting in a combinatorial explosion of the amount of bytecode that has to be deployed, once for each combination of these variations, leading to exponentially growing deployment costs.
There are two possible solutions to this:  

Dispatcher contract
---
A naive solution might use a dispatcher contract D and 'libraries' (not the current Solidity kind) La, Lb, ... , repeatedly calling on the D to (delegate)call a function from another library Lx.
The problems with this are threefold:

1. Call instructions themselves cost considerable amounts of gas.
2. There is no cross-library optimization performable on the number of SSLOAD and SSTORE instructions, leading to massively higher gas costs.
3. delegatecall does not make return values easily accessible, which vastly complicates the usage.

These problems might be fixed by allowing internal calls into other contracts, such that all relevant information is loaded to memory once by D, operated on by the Lx (which jumps are performed to / between), and then stored again by D.
However, this would require a **change to the EVM**, which is why I propose the solution below.

Dynamic Inheritance
---
The alternative is to create new contracts N1 not just from one other N0 , but to allow creating it from more than one by combining for example Na and Nb into Nab, also known as dynamic inheritance or runtime inheritance.

Here, all relevant Lx would be copied together into the new contract N1. This requires the patching of jump locations, for which the bytecode is generated by the compiler.
Similarly to the solution proposed above, the relevant storage values would only be loaded / stored once.

With a small backwards-compatible extension to the ABI it might even be possible to allow inheritance from Lx not compiled together with the deploying contracts.
This would be achieved by including a list of internal functions and the storage locations they access, allowing the patching of the instructions for these accesses to instructions for accessing memory.

In contrast, this only requires a **change to Solidity**.  

---
(Using mega-contracts that include all of the possibly needed variations Nabc... is both terrible for extensibility and not viable under the current block gas limit.)

Thanks for reading and consideration, I'm interested what you think about this idea. Feel free to correct me if I got anything wrong.

#### <img src="https://avatars.githubusercontent.com/u/20340?v=4" width="50">[axic](https://github.com/axic) commented at [2018-01-29 22:48](https://github.com/ethereum/solidity/issues/3449#issuecomment-361414070):

I think this proposal needs some refining into a more readable form and listing the problems and possible solutions.

I have the feeling that some solutions proposed there are outside the scope of Solidity and not even sure that any of them fall into the scope of the Solidity compiler.

Would be happy to read again a refined version.

#### <img src="https://avatars.githubusercontent.com/u/9434715?u=66d3c1845462fc37b63fa8d6e4e62e1ede0ea4ab&v=4" width="50">[hyperfekt](https://github.com/hyperfekt) commented at [2018-01-29 23:26](https://github.com/ethereum/solidity/issues/3449#issuecomment-361422707):

Thanks for your comment!
I do hope this is a bit more (not less) readable.

In my mind Solidity is the only scope the second solution could fall in - if they're not in the scope of Solidity I don't think the problem will be solved at all.

#### <img src="https://avatars.githubusercontent.com/u/2512?v=4" width="50">[redsquirrel](https://github.com/redsquirrel) commented at [2018-01-30 14:56](https://github.com/ethereum/solidity/issues/3449#issuecomment-361618249):

> Currently the only way to create a new contract N1 from another contract C is to either include all of N1's bytecode in C, or to copy an already deployed contract N0.

Wouldn't another way be to create an N1Factory contract and have C (and other contracts) call N1Factory.create?

#### <img src="https://avatars.githubusercontent.com/u/9434715?u=66d3c1845462fc37b63fa8d6e4e62e1ede0ea4ab&v=4" width="50">[hyperfekt](https://github.com/hyperfekt) commented at [2018-01-30 15:51](https://github.com/ethereum/solidity/issues/3449#issuecomment-361636762):

Well, that's just redesignating C as N1Factory. Who owns the created contract in the end is irrelevant. Usually C would indeed be a factory of some sort.
Crucially, N1Factory still has to include the entire bytecode of N1.

#### <img src="https://avatars.githubusercontent.com/u/2512?v=4" width="50">[redsquirrel](https://github.com/redsquirrel) commented at [2018-01-30 16:45](https://github.com/ethereum/solidity/issues/3449#issuecomment-361655676):

Ah, and the factory would also have to handle the "combinatorial explosion of the amount of bytecode that has to be deployed". Understood. This is possibly off-topic, but I'm be curious about your contract design and why you need to rely so heavily on inheritance (vs composition).

#### <img src="https://avatars.githubusercontent.com/u/9434715?u=66d3c1845462fc37b63fa8d6e4e62e1ede0ea4ab&v=4" width="50">[hyperfekt](https://github.com/hyperfekt) commented at [2018-01-30 17:17](https://github.com/ethereum/solidity/issues/3449#issuecomment-361666024):

It's because the architecture is highly flexible - I'm building transaction contracts that (for now) can be all sorts of auctions - open, sealed, ascending, descending, buying, selling, first-price, second-price, for deeds, ens domains,  tokens, with Ether or with tokens, ...
As you can imagine they respectively share quite a bit of code but not all of it.

Composition of different contracts would not be feasible because the passing of structs or storage references across contracts isn't possible (besides incurring huge call overheads).

#### <img src="https://avatars.githubusercontent.com/u/20340?v=4" width="50">[axic](https://github.com/axic) commented at [2018-01-30 17:57](https://github.com/ethereum/solidity/issues/3449#issuecomment-361678790):

Are you sure it cannot be achieved by using Solidity libraries for those functions and parametirizing th constructor of the deployable instances in the factory?

#### <img src="https://avatars.githubusercontent.com/u/9434715?u=66d3c1845462fc37b63fa8d6e4e62e1ede0ea4ab&v=4" width="50">[hyperfekt](https://github.com/hyperfekt) commented at [2018-01-30 18:08](https://github.com/ethereum/solidity/issues/3449#issuecomment-361682267):

AFAIK internal calls to libraries inline those, meaning the bytecode is still duplicated for each constructor. Is that wrong?

#### <img src="https://avatars.githubusercontent.com/u/20340?v=4" width="50">[axic](https://github.com/axic) commented at [2018-01-30 18:12](https://github.com/ethereum/solidity/issues/3449#issuecomment-361683623):

You don't need to mark library functions `internal`. If you do not, then they are not inlined.

#### <img src="https://avatars.githubusercontent.com/u/9434715?u=66d3c1845462fc37b63fa8d6e4e62e1ede0ea4ab&v=4" width="50">[hyperfekt](https://github.com/hyperfekt) commented at [2018-01-30 19:42](https://github.com/ethereum/solidity/issues/3449#issuecomment-361710560):

That's true. The problem with using libraries is that they cannot call upon other libraries that are not predetermined when the library is deployed, which precludes anything but the simplest designs.

#### <img src="https://avatars.githubusercontent.com/u/20340?v=4" width="50">[axic](https://github.com/axic) commented at [2018-01-30 19:59](https://github.com/ethereum/solidity/issues/3449#issuecomment-361715935):

I think that may be a separate issues and not directly related to this. The same way you need to store somewhere all the components, you may as well choose to:
- a) have different versions of libraries deployed (with different compositions)
- b) have all the components as libraries and the child contract use it depending on constructor parameters

I am not really sure how do you imagine having a lot of components and composing them into a bytecode during creation time, also not fully sure about the motivation. Which is more importat: deployment gas cost? runtime gas cost?

Writing a practical example may help in calculating rough figures of gas usage and visualising the complixity.

#### <img src="https://avatars.githubusercontent.com/u/382183?u=499298f335f6f4f2b2498c3510275590dd8e67fc&v=4" width="50">[fulldecent](https://github.com/fulldecent) commented at [2018-01-31 20:23](https://github.com/ethereum/solidity/issues/3449#issuecomment-362059173):

Why is everybody so afraid of deploying the contract again after they make some changes?

I am glad the `CALL` methods cost a lot of gas and they discourage "DELEGATE EVERYTHING" behavior!

#### <img src="https://avatars.githubusercontent.com/u/9434715?u=66d3c1845462fc37b63fa8d6e4e62e1ede0ea4ab&v=4" width="50">[hyperfekt](https://github.com/hyperfekt) commented at [2018-01-31 20:50](https://github.com/ethereum/solidity/issues/3449#issuecomment-362066073):

@axic
a) Having all these different versions deployed is still subject to the same combinatory explosion, therefore I do not see how that would solve the problem I described?
b) This requires calls between libraries, which costs massive amounts of gas, and passing around the entire state of the contract (which is only possible for those with rather little), or paying even more gas in storage instructions.
I imagine deployment gas cost to be feasible at all, and runtime gas cost to be less than crazy for the amount of work performed.
The point is that libraries are strictly less powerful than necessary for this scenario.
Composition into a single contract would be performed as I mentioned: Copying together functions with a fixed heap layout over all of them, and patching jump locations.
I feel like I am repeating myself here; but I will create a few versions to illustrate how this actually causes pain in practice.

@fulldecent This is less about forwarding onto another contract, I agree that deployed contracts should be immutable. The point is composing contracts, not changing them.

#### <img src="https://avatars.githubusercontent.com/u/20340?v=4" width="50">[axic](https://github.com/axic) commented at [2018-02-01 11:00](https://github.com/ethereum/solidity/issues/3449#issuecomment-362232160):

> Copying together functions with a fixed heap layout over all of them, and patching jump locations.

You are proposing a deploy time linker, written in EVM. Do you think this is low complexity enough to not cause a lot of potential issues and at the same time is cheap enough to be done within the block gas limit? :)

Also I am still waiting for an actual practical example (and by that I mean some code snippets) where this is needed.

#### <img src="https://avatars.githubusercontent.com/u/224810?u=9d4bdd31329b33f97dbee8e1e3e6f01fa1369d09&v=4" width="50">[3esmit](https://github.com/3esmit) commented at [2018-12-16 05:19](https://github.com/ethereum/solidity/issues/3449#issuecomment-447618690):

Solidity could propose a convention on use of `delegatecall' for the end use of dynamic inheritance. 
I think is a fair use case of solidity, specially if you are writing a contract intended to be a user account contract, which a requirement might be either upgrade-ability or extend-ability.

I agree that this is too high complexity for the compiler, however the design of language should consider the use of delegatecall. For example, better documentation on how the storage layout is written, a solidity implementation for `exit-return`, useful for attaching views from a delegatecall. 

```solidity
            bytes memory returnData;
            bool success;
            (success, returnData) = _target.delegatecall(msg.data);
            require(success, "Delegated Call failed"); 

            //exit-return delegatecall returnData
            assembly {
                return(add(returnData, 0x20), returnData) 
            }
```

#### <img src="https://avatars.githubusercontent.com/in/15368?v=4" width="50">[github-actions](https://github.com/apps/github-actions) commented at [2023-02-14 12:05](https://github.com/ethereum/solidity/issues/3449#issuecomment-1429635965):

This issue has been marked as stale due to inactivity for the last 90 days.
It will be automatically closed in 7 days.

#### <img src="https://avatars.githubusercontent.com/in/15368?v=4" width="50">[github-actions](https://github.com/apps/github-actions) commented at [2023-02-21 12:05](https://github.com/ethereum/solidity/issues/3449#issuecomment-1438366069):

Hi everyone! This issue has been automatically closed due to inactivity.
If you think this issue is still relevant in the latest Solidity version and you have something to [contribute](https://docs.soliditylang.org/en/latest/contributing.html), feel free to reopen.
However, unless the issue is a concrete proposal that can be implemented, we recommend starting a language discussion on the [forum](https://forum.soliditylang.org) instead.


-------------------------------------------------------------------------------



[Export of Github issue for [ethereum/solidity](https://github.com/ethereum/solidity). Generated on 2024.12.15 at 06:45:24.]
