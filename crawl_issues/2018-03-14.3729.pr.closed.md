# [\#3729 PR](https://github.com/ethereum/solidity/pull/3729) `closed`: [DO NOT MERGE] Clean up inheritance specification.

#### <img src="https://avatars.githubusercontent.com/u/9073706?v=4" width="50">[chriseth](https://github.com/chriseth) opened issue at [2018-03-14 09:05](https://github.com/ethereum/solidity/pull/3729):

This is a pull request to discuss the changed inheritance specification for version 0.5.0.

#### <img src="https://avatars.githubusercontent.com/u/382183?u=499298f335f6f4f2b2498c3510275590dd8e67fc&v=4" width="50">[fulldecent](https://github.com/fulldecent) commented at [2018-03-14 15:03](https://github.com/ethereum/solidity/pull/3729#issuecomment-373053395):

Can you please explain "the most derived function is called, except when the contract name is explicitly given."

Does that mean in the future I can do this:

```solidity
pragma solidity ^0.4.21;

contract Animal {
    function toString() private pure returns (string) {
        return "animal";
    }
    
    function favoriteCrackers() external pure returns (string) {
        return /*concat(*/ Animal.toString() /*," crackers")*/;
    }
}

contract Dog is Animal {
    function toString() private pure returns (string) {
        return "dog";
    }
}
```

and get animal crackers?

#### <img src="https://avatars.githubusercontent.com/u/382183?u=499298f335f6f4f2b2498c3510275590dd8e67fc&v=4" width="50">[fulldecent](https://github.com/fulldecent) commented at [2018-03-14 15:03](https://github.com/ethereum/solidity/pull/3729#issuecomment-373053460):

This is confusing

> ... this means that visibility and mutability of functions cannot be restricted, but it can be extended.

because visibility can be extended, but mutability can be restricted. Really the thing that is being extended is the *immutability*. Perhaps a way to say this is:

> ... this means that visibility and mutability of functions can make stronger guarantees, not weaker.

Please consider more explicit override documentation. Perhaps use these tables.

# Allowed function overrides:

| If a function is... | then an override of that function must be one of... |
| -------------------- | --------------------------------------------------- |
| `public`            | `public`                                |
| `external`          | `public`, `external`                                 |
| `internal`          | `public`, `internal`                     |
| `private`           | (must not override)                                 |

| If an interface/contract function is... | then an inheriting interface/contract that overrides that function must be one of... |
| ------------------------------ | ----------------------------------------------- |
| `pure`                         | `pure`                                          |
| `view`                         | `pure`, `view`                                 |
| implicit non-payable           | `pure`, `view`, implicit non-payable |
| `payable`                      | `pure`, `view`, implicit non-payable, `payable`|

| If a contract state variable is... | then an inheriting contract that overrides that with a function must be one of... |
| ---------------------------------- | ------------------------------------------------------------ |
| `public`                           | `pure`, `view`, implicit non-payable     |

**NOTE: that last one adds more prescription than what is currently in the PR. The others are simply reference/clarity of what you have already said.**

#### <img src="https://avatars.githubusercontent.com/u/382183?u=499298f335f6f4f2b2498c3510275590dd8e67fc&v=4" width="50">[fulldecent](https://github.com/fulldecent) commented at [2018-03-14 15:20](https://github.com/ethereum/solidity/pull/3729#issuecomment-373059848):

Please bump the solidity version on that example in the PR.

---

Please move todo items from the commit into your top comment in this PR.

---

This text is killing me:

+It is an error for two contracts in an inheritance hierarchy to have a member of the same name,
+unless one member (``f_B``) is defined in a class (``B``) that derives (directly or indirectly) from the
+class (``A``) the other member (``f_A``) is defined in; and: ``f_B`` uses the ``override`` keyword, ``f_A`` is a
+function and ``f_B`` is either a function or a public state variable, both are compatible with
+regards to visibility and state mutability as per the above rules and both have exactly the same
+parameter and return types.

Perhaps this can be simplified:

> Every function of a contract must be defined **once**, and may be overridden as per the rules above. Therefore it is an error for a contract's inheritance hierarchy (of contracts and interfaces) to include the same function definition more than once.

or...

> Every function of a contract must be defined **once**, and may be overridden as per the rules above. Therefore it is an error for a contract's inheritance hierarchy of contracts to include the same function definition more than once.

The nuance here is whether or not the following should be legal:

```solidity
interface ERC20 {
   string name ...
}
interface ERC721Metadata {
   string name...
}
contract TokenToNFTConverter is ERC20, ERC721Metadata {
   function name() ...
}
```

#### <img src="https://avatars.githubusercontent.com/u/382183?u=499298f335f6f4f2b2498c3510275590dd8e67fc&v=4" width="50">[fulldecent](https://github.com/fulldecent) commented at [2018-03-14 15:30](https://github.com/ethereum/solidity/pull/3729#issuecomment-373063556):

Recommend:

> * It is an error for any function to override using a different return type.

#### <img src="https://avatars.githubusercontent.com/u/9073706?v=4" width="50">[chriseth](https://github.com/chriseth) commented at [2018-03-14 15:37](https://github.com/ethereum/solidity/pull/3729#issuecomment-373066259):

@fulldecent can you please comment on the specific lines in the files?

#### <img src="https://avatars.githubusercontent.com/u/382183?u=499298f335f6f4f2b2498c3510275590dd8e67fc&v=4" width="50">[fulldecent](https://github.com/fulldecent) commented at [2018-03-14 15:50](https://github.com/ethereum/solidity/pull/3729#issuecomment-373071310):

I have reviewed all my open issues on this topic and summarized below. Woah.

THIS PR FIXES:
* Fixes #3514 Allow contact's public state variable to implement interface function 
* Fixes #3412 Implement interface: allow stricter mutability
* Fixes #3419 Interfaces can't inherit
* Fixes #3420 Interfaces are useless, scrap them

POTENTIAL BLOCKERS:
* #3459 Allow modifier declaration with no implementation
  * Currently this PR does not allow this. Perhaps it should be in scope for this discussion
* #3454 Allow private visibility for modifier keyword
  * Currently this PR does not address this issue. Perhaps it should be in scope here.
* #3421 Compiler does not consider events when validating contract inheritance
  * We should fix this!
* #3418 Allow NatSpec comments for variables
  * We should fix this because we are now introducing an `@inherit` natspec keyword. (We should also include an example of how that keyword works.)

OTHER NOTES:
* #3506 Allow static access to contract & interface function selectors
  * Is impacted by inheritance, but does not block this PR

#### <img src="https://avatars.githubusercontent.com/u/9073706?v=4" width="50">[chriseth](https://github.com/chriseth) commented at [2018-03-14 16:48](https://github.com/ethereum/solidity/pull/3729#issuecomment-373093323):

Idea from weekly discussion: Overriding and overloading cannot be combined unless all overloads are overridden in the derived class.

#### <img src="https://avatars.githubusercontent.com/u/382183?u=499298f335f6f4f2b2498c3510275590dd8e67fc&v=4" width="50">[fulldecent](https://github.com/fulldecent) commented at [2018-03-14 16:59](https://github.com/ethereum/solidity/pull/3729#issuecomment-373097167):

A note from the weekly discussion. There may be user complaints about the policy to not allow inheriting from two unrelated interfaces/contracts with the same name.

Example: a contract that implements ERC-20 and ERC-721.

A solution: require ERC-20 and ERC-721 to derive from a common base class.

An issue with that: currently the ERC-165 interface identifier does consider functions from inherited interfaces (also codified in ERC-721, 721 requires 165 but does NOT include `supportsInterface` in its identifier).

#### <img src="https://avatars.githubusercontent.com/u/9073706?v=4" width="50">[chriseth](https://github.com/chriseth) commented at [2018-03-14 17:07](https://github.com/ethereum/solidity/pull/3729#issuecomment-373100082):

Proposal by @axic: Separate inlining and visibility aspect of libraries: https://github.com/ethereum/solidity/issues/2739#issuecomment-373098823

#### <img src="https://avatars.githubusercontent.com/u/9073706?v=4" width="50">[chriseth](https://github.com/chriseth) commented at [2018-03-15 12:37](https://github.com/ethereum/solidity/pull/3729#issuecomment-373361441):

@fulldecent sorry, but I still do not fully understand. If ERC-721 is backwards-compatible to ERC-20, then it should inherit from ERC-20, shouldn't it?

Could you also explain the problem with ERC-165?

#### <img src="https://avatars.githubusercontent.com/u/382183?u=499298f335f6f4f2b2498c3510275590dd8e67fc&v=4" width="50">[fulldecent](https://github.com/fulldecent) commented at [2018-03-15 14:29](https://github.com/ethereum/solidity/pull/3729#issuecomment-373395152):

@chriseth ERC-721 is NOT backwards compatible to ERC-20. However, some of the function names are intentionally reused.

Here is [how 721 currently works](https://github.com/fulldecent/EIPs/blob/patch-2/EIPS/eip-721.md):

```solidity
interface ERC721 /* is ERC165 */ {
    function A...
    function B...
}

interface ERC721Metadata /* is ERC721 */ {
    function C...
    function D...
}

interface ERC721Enumerable /* is ERC721 */ {
    function E...
    function F...
}
```

The interface identifiers are explicitly stated in EIP-721 and they are:

* `ERC721_ID = hash(A) ^ hash(B)`
* `ERC721Metadata_ID = hash(C) ^ hash(D)`
* `ERC721Enumerable_ID = hash(E) ^ hash(F)`

The specification also states that an ERC-721 contract must support ERC-165 (and support the interface `0x01ffc9a7`). However, the `supportsInterface` is NOT included in `function A`, `function B` above.

Also, please note that EIP-137, the ENS (final status), works the same way where "inherited interfaces" are not included in the interface ID.

Pinging @spalladino, because he is working on an important implementation of 721.

Note: Solidity is considering to add something like `ERC721.interfaceID` which will calculate the ERC-165 identifier for an interface (issue number?). This would be impacted by the way that inheritance of functions is handled.

#### <img src="https://avatars.githubusercontent.com/u/429604?u=8f63ca38c804c79ee0b933d57c1c535c7b8a088a&v=4" width="50">[spalladino](https://github.com/spalladino) commented at [2018-03-15 21:24](https://github.com/ethereum/solidity/pull/3729#issuecomment-373527587):

Thanks for the heads-up @fulldecent, but the current implementation does not yet support 165. I'll be sure to keep an eye on this discussion before moving onto it.

#### <img src="https://avatars.githubusercontent.com/u/9073706?v=4" width="50">[chriseth](https://github.com/chriseth) commented at [2018-03-19 11:10](https://github.com/ethereum/solidity/pull/3729#issuecomment-374176882):

@fulldecent I think we should decouple the restrictions concerning functions to be overridden and the way the interface id works. If an interface is seen as a mere extension, then its identifier only contains the "new" functions. If it is seen as including the interface it extends, it includes all inherited functions, too. There should probably be two keywords to access the two ways to view the identifier. Even if not, since the identifier is computed using xor, you can just do `extensionIdentifier = fullIdentifier ^ baseIdentifier` to remove the old functions from the full identifier.

#### <img src="https://avatars.githubusercontent.com/u/9601008?u=9efd0adfccd16b218a02dcfacc5d23e23529c642&v=4" width="50">[OTTTO](https://github.com/OTTTO) commented at [2018-03-27 15:41](https://github.com/ethereum/solidity/pull/3729#issuecomment-376572777):

@chriseth, in regards to your last reference
I think we should allow public variable declarations in interfaces.
```
interface ERC20Basic {
  uint256 public totalSupply;
  function balanceOf(address who) public view returns (uint256);
  function transfer(address to, uint256 value) public returns (bool);
  event Transfer(address indexed from, address indexed to, uint256 value);
}
```
instead of..
```
contract ERC20Basic {
  function totalSupply() public view returns (uint256);
  function balanceOf(address who) public view returns (uint256);
  function transfer(address to, uint256 value) public returns (bool);
  event Transfer(address indexed from, address indexed to, uint256 value);
}
```

#### <img src="https://avatars.githubusercontent.com/u/382183?u=499298f335f6f4f2b2498c3510275590dd8e67fc&v=4" width="50">[fulldecent](https://github.com/fulldecent) commented at [2018-03-28 18:11](https://github.com/ethereum/solidity/pull/3729#issuecomment-376983484):

May I please see a specific example where allowing override of just one part of an overloaded function is bad?

#### <img src="https://avatars.githubusercontent.com/u/9073706?v=4" width="50">[chriseth](https://github.com/chriseth) commented at [2018-04-04 10:42](https://github.com/ethereum/solidity/pull/3729#issuecomment-378557727):

@OTTTO interfaces are not meant to enforce storage layout, and if you use a public state variable in an interface, you do that. You will be able to "implement" an external interface function with a public state variable, though.

@fulldecent it is just a complicated case, and I think it is better to be explicit about those. Readers might not think about the fact that the function in the base contract is used for the other overload.

#### <img src="https://avatars.githubusercontent.com/u/382183?u=499298f335f6f4f2b2498c3510275590dd8e67fc&v=4" width="50">[fulldecent](https://github.com/fulldecent) commented at [2018-05-17 21:25](https://github.com/ethereum/solidity/pull/3729#issuecomment-390017159):

Will the Solidity team consider to allow a limited few Mermaid diagrams inside the readthedocs documentation?

#### <img src="https://avatars.githubusercontent.com/u/9073706?v=4" width="50">[chriseth](https://github.com/chriseth) commented at [2018-05-28 20:34](https://github.com/ethereum/solidity/pull/3729#issuecomment-392599463):

@fulldecent html is only one target of our documentation, we also generate pdfs and stuff. Would it be possible to use something portable like svg? :)

#### <img src="https://avatars.githubusercontent.com/u/9073706?v=4" width="50">[chriseth](https://github.com/chriseth) commented at [2018-06-27 12:14](https://github.com/ethereum/solidity/pull/3729#issuecomment-400650321):

It should not be possible to override events at all. If we still allow it, we have to take the indexedness of parameters into account when comparing (from https://github.com/ethereum/solidity/issues/4168).

#### <img src="https://avatars.githubusercontent.com/u/382183?u=499298f335f6f4f2b2498c3510275590dd8e67fc&v=4" width="50">[fulldecent](https://github.com/fulldecent) commented at [2018-07-03 01:11](https://github.com/ethereum/solidity/pull/3729#issuecomment-401982803):

This seems oddly related to inheritance, so I'll ask.

Should lazy instantiation of variables be in scope for the inheritance rewrite? You may think of this as "inheriting a variable". Also, the below behavior is consistent with Swift language, and maybe some others.

```solidity
pragma solidity ^0.4.24;

// TEST CASE 1
// - No compiler error
// - If trying to deploy, produce error "Uninitialized variable `b`"
contract A {
    int constant a = 5;
    int constant b;
}

// TEST CASE 2
// - No compiler error
// - No error on deploy
contract B {
    int constant a = 5;
    int constant b;
    constructor() {
        b = 5;
    }
}

// TEST CASE 3
// - No compiler error
// - No error on deploy
contract C is A {
    constructor() {
        b = 5;
    }
}
```

#### <img src="https://avatars.githubusercontent.com/u/382183?u=499298f335f6f4f2b2498c3510275590dd8e67fc&v=4" width="50">[fulldecent](https://github.com/fulldecent) commented at [2018-07-03 02:32](https://github.com/ethereum/solidity/pull/3729#issuecomment-401994567):

We had a phone call about overloading / overriding.

Could somebody please document the main points of that discussion here?

---

Also I believe default function parameters can be in scope for this issue. Please let me know your thoughts. Example:

```solidity
function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data = "") external payable;
```

Note Vyper just announced they would support this feature and argued that it would improve readability and security. Also note they are strongly against function overloading -- so this was a nuanced discussion.

#### <img src="https://avatars.githubusercontent.com/u/382183?u=499298f335f6f4f2b2498c3510275590dd8e67fc&v=4" width="50">[fulldecent](https://github.com/fulldecent) commented at [2018-07-04 03:53](https://github.com/ethereum/solidity/pull/3729#issuecomment-402355688):

This current states that "constructors cannot be overriden". This is literally correct, but it may be helpful to note that constructors of parent contracts are incorporated. Also, it may be helpful to document which order they are run in.

---

@chriseth I am ready to move forward with this. I can make a PR that address all these issues and includes test cases / examples.

I would just like to know if there is consensus on the above items before I start, and I'd like to hear your thoughts on overloading/overriding.

Lastly, it will help if you can confirm Solidity has an appetite for this change at this time.

#### <img src="https://avatars.githubusercontent.com/u/9073706?v=4" width="50">[chriseth](https://github.com/chriseth) commented at [2018-07-04 12:05](https://github.com/ethereum/solidity/pull/3729#issuecomment-402459218):

Yes, please move forward with this! We need someone who can dive deep and take the time to see if there are any inconsistencies. There is a big appetite for a clean structure in the rules, certainly! We won't get that for 0.5.0, but it is planned for 0.6.0 (with the time between 0.5.0 and 0.6.0 hopefully being much shorter than betwene 0.4.0 and 0.5.0).

Note that default parameter values for external function is a bit tricky for non-value types, since external parameters have a `calldata` data location and there is no way to modify calldata, so I would only allow that for `public` functions for now.

#### <img src="https://avatars.githubusercontent.com/u/382183?u=499298f335f6f4f2b2498c3510275590dd8e67fc&v=4" width="50">[fulldecent](https://github.com/fulldecent) commented at [2018-07-12 02:01](https://github.com/ethereum/solidity/pull/3729#issuecomment-404365563):

@chriseth Thank you. And lastly, can you please document your notes on confluence between overloading and overriding?

#### <img src="https://avatars.githubusercontent.com/u/9073706?v=4" width="50">[chriseth](https://github.com/chriseth) commented at [2018-07-16 11:48](https://github.com/ethereum/solidity/pull/3729#issuecomment-405222038):

@fulldecent sorry, can you be more specific, please?

#### <img src="https://avatars.githubusercontent.com/u/382183?u=499298f335f6f4f2b2498c3510275590dd8e67fc&v=4" width="50">[fulldecent](https://github.com/fulldecent) commented at [2018-08-22 23:54](https://github.com/ethereum/solidity/pull/3729#issuecomment-415225557):

Ok @chriseth here is my entire proposal for rewriting the interface specification in Solidity, told as a story of test cases. This closes the majority of issues I have opened in this repository.

I think test cases are the most efficient way to move this proposal along. After we have something good, I can help with documentation and get this into a proper PR. You're welcome to give me a call regarding the project and timelines and stuff like that, this will help me be available for the important parts. Also, I can join the team call to review anything here if you will add me to the agenda and let me know when it is. Thanks for your help with this.

Most controversial parts:
* Disallows overriding private functions, adds strong opinions on private function naming directly into the language. Compare and contrast this to Python (we recognize them as an influencer for Solidity) which does not have private functions at all and they have a language built-in feature for mangling some symbol names. Personally I find their approach to be a little opaque, so this proposal is a little more explicit. (TEST 8)
* Overloading and overriding can be mixed and matched.

Here it goes...

```solidity
pragma solidity ^0.4.24;
pragma experimental "v0.5.0";

// INTERFACE INHERITANCE ///////////////////////////////////////////////////////

// TEST 1 - an interface can inherit an interface
interface Car {
    function numberOfWheels() external view returns (int);
}

interface ElectricCar is Car {
    // numberOfWheels() is also part of ElectricCar
    function vroomtoneVolume() external view returns (int);
}

// TEST 2 - an interface cannot inherit a contract
contract ChevyVolt2015 {
}

interface ChevyElectricCars is ChevyVolt2015 {
}

// TEST 2.5 - interface ID follows ERC-165 and ERC-721 precedence
// note if you want your interfaceID include elements from a parent interface
// then just explicitly add those interface members to your interface
interface ERC721 { /* ... */ }

interface ERC721Metadata { /* ... */ }

contract TestInterfaceId {
    function() external {
        assert(ERC721.interfaceID == 0x80ac58cd);
        assert(ERC721Metadata.interfaceID == 0x5b5e139f);
    }
}

// CONTRACT INHERITANCE ////////////////////////////////////////////////////////

// TEST 3 - a contract can inherit a contract
contract ChevyVolt {
}

contract BuickVelite5 is ChevyVolt {
}

// TEST 4 - a contract can inherit an interface
contract TeslaModel3 is ElectricCar {
}

// MULTIPLE INHERITANCE ////////////////////////////////////////////////////////

// TEST 5 - latter inheritances take precedence
contract Lion {
    function hasStripes() external view returns(bool) {return false;}
}

contract Tiger {
    function hasStripes() external view returns(bool) {return true;}
}

contract Liger is Lion, Tiger {
    // hasStripes() returns true, and yes a liger actually has stripes
}

// FUNCTION SIGNATURES /////////////////////////////////////////////////////////

// TEST 6 - inheriting functions may make stronger mutability guarantees
interface Math {
    // Is is legal for implementations of Math to require payment to run
    function calculateMostCommonNumberInSolidityDocumentation() external payable returns (int);
}

contract MathImplementation is Math {
    // It is not legal for implementations of MathImplementation to require
    // payment to run
    function calculateMostCommonNumberInSolidityDocumentation() external returns (int) {
        return 69;
    }
}

interface Meteorology {
    // It is legal for implementations of Meteorology to change the temperature
    // and save to storage before returning a value
    function calculateTemperature() external returns (int);
}

contract PassiveMeteorology is Meteorology {
    function calculateTemperature() external view returns (int);
}

interface NamedThing {
    function name() external view returns (string);
}

contract Bob is NamedThing {
    function name() public pure returns (string) {
        return "Bob";
    }
}

// TEST 7 - inheriting functions may make more open visability guarantees
interface NonOwnedToken {
    function totalSupply() external view returns (uint256);
}

contract SunshineToken {
    // Here the function is public and can be used from this and inheriting
    // contract functions
    function totalSupply() public view returns (uint256);
}

contract BusinessLogicLibrary {
    function formula() internal view returns (string);
}

contract BusinessApplication is BusinessLogicLibrary {
    function formula() public view returns (string);
}

contract Counter {
    int private count;
}

contract CountingService is Counter {
    int public count;
}

// TEST 8 - private functions cannot be inherited
// Rationale: Python doesn't even have private functions, they have name
// mangling instead
// Style note: we should recommend that every private function's name should
// start with two underscores and the name of the contract.
// NOTE: This is a breaking change!
contract Tokenizer {
    int private __TokenizerStringLocation;
    function strtok(string) internal view returns (string);
}

contract StringUtilities is Tokenizer {
    int private __TokenizerStringLocation; // <--- THIS IS AN ERROR
    int public __TokenizerStringLocation; // <--- THIS IS AN ERROR
    int private __TokenizerSomethingElse; // <--- THIS IS A WARNING
}

// VARIABLES ///////////////////////////////////////////////////////////////////

// TEST 9 - variables ARE functions for overriding purposes
contract Truck {
    int public numberOfWheels; // Note: this implies a view mutability
}

contract HondaTruck is Truck {
    function numberOfWheels() public returns (int); // <--- THIS IS AN ERROR, MUTABILITY IS NOT COMPATIBLE
}

contract MercedesTruck is Truck {
    function numberOfWheels() public view returns (int);
}

// EVENTS //////////////////////////////////////////////////////////////////////

// TEST 10 - it is rudundant (but allowed) for an overriding contract to
// redefine an event. But it is illegal to rededine it differently

contract A {
    event Transfer(address indexed from, address to);
}

// This should fail -- event signature is different
contract B is A {
    event Transfer(address indexed from, address to, address other);
}

// This should fail -- event signature is different than parent
contract C is A {
    event Transfer(address indexed from, address indexed to);
}

// This should fail -- event signature is different than parent
contract D is A {
    event Transfer(address from, address to);
}

// OVERLOADING /////////////////////////////////////////////////////////////////

// TEST 11 - it is possible to override a contract with an overloaded function
// note an overloaded function is just syntatical sugar

interface ERC721Partial {
    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) external payable;
    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;
}

// Note: this fully implements both functions from the interface
contract ERC721PartialImplementation is ERC721Partial {
    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data = "") external payable {
        /* ... */
    }
}

// TEST 12 - you can overload part of an overloaded function, if so the routing
// still works
contract ERC721PartialImplementation2 is ERC721PartialImplementation {
    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable {
        /* ... */
    }
}

// NOTES

// DON"T DO THIS
// Note: I considered to allow this as well but it is a bad idea because it is
// adding implementations details (= "") into an interface.
interface ERC721Partial2 is ERC721Partial {
    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data = "") external payable;
}

// MAYBE DO THIS
// This would be equivalent to the ERC721Partial above. The way default works is
// only the right-most parameters may be "default". And a function with N
// default parameters will have N+1 function signatures.
interface ERC721Partial2 is ERC721Partial {
    function safeTransferFrom(address _from, address _to, uint256 _tokenId, default bytes data) external payable;
}

// TEST 13 - it is okay to add overloading
interface A {
    function bob() public;
}

contract B is A {
    function bob(uint256 mary) public pure {
        mary = mary;
        return;
    }
}

// MODIFIERS ///////////////////////////////////////////////////////////////////

// TEST 14 - a modifier can be private

contract Test1 {
    modifier mod private {
        require(false);
        _;
    }
}

// TEST 15 - a modifier can be internal or implicitly internal

contract Test2 {
    modifier mod internal {
        require(false);
        _;
    }
}

contract Test3 {
    modifier mod {
        require(false);
        _;
    }
}

// TEST 16 - a private modifier cannot be overriden (just like functions)

contract Test4A {
    modifier mod private {
        require(false);
        _;
    }
}

contract Test4B is Test4A {
    modifier mod private { // <--- ERROR: YOU CANNOT OVERRIDE A PRIVATE MODIFIER
        require(false);
        _;
    }
}

contract Test5A {
    modifier mod private {
        require(false);
        _;
    }
}

contract Test5B is Test5A {
    modifier mod internal { // <--- ERROR: YOU CANNOT OVERRIDE A PRIVATE MODIFIER
        require(false);
        _;
    }
}

// TEST 17 - a private modifier cannot override an internal modifier

contract Test6A {
    modifier mod internal {
        require(false);
        _;
    }
}

contract Test6B is Test6A {
    modifier mod private { // <--- ERROR: A PRIVATE MODIFIER CANNOT OVERRIDE AN INTERNAL MODIFIER
        require(false);
        _;
    }
}

// TEST 18 - an internal modifier CAN override an internal modifier

contract Test7A {
    modifier mod internal {
        require(false);
        _;
    }
}

contract Test7B is Test7A {
    modifier mod internal {
        require(false);
        _;
    }
}

// TEST 19 - a private modifier cannot be used outside of scope

contract Test8A {
    modifier mod private {
        require(false);
        _;
    }
}

contract Test8B is Test8A {
    function Test8B() mod public { // <-------- Error, modifier mod is not visible here
    }
}

// TEST 20 - a virtual modifier can be defined

contract Test9A {
    modifier isAuthorized;
    function doTransaction() external isAuthorized;
}

contract Test9B is Test9A {
    modifier isAuthorized {
        // implement authorization-checking business logic here
        _;
    }
}

// DYNAMIC DISPATCH ////////////////////////////////////////////////////////////

//TODO: Add test cases here that explain that the most derived function or
// modifier is the one that works

// OBJECT ORIENTED PROGRAMMING /////////////////////////////////////////////////

//TODO: Add test cases here that show how to use explicit scoping to call the
// not-most-derived function. This includes constructors that call the base
// contract constructors (can be multiple). Also includes using `super.` to call
// an inherited function. Unfortunately super. can be ambiguous for multiple-
// inheritance. I say that in this situation we should choose a function based
// on the which function would run if there was no override.
```

#### <img src="https://avatars.githubusercontent.com/u/9073706?v=4" width="50">[chriseth](https://github.com/chriseth) commented at [2018-09-03 14:58](https://github.com/ethereum/solidity/pull/3729#issuecomment-418138880):

@fulldecent I think starting from examples / test cases is a good idea, but I think that each test case needs a full and clear description of the rule. Please go ahead and create a pull request, so we can properly discuss!

#### <img src="https://avatars.githubusercontent.com/u/18387287?u=731c7dd6ee0b0893495e80299d0849c4d09e826b&v=4" width="50">[wadealexc](https://github.com/wadealexc) commented at [2018-09-10 15:09](https://github.com/ethereum/solidity/pull/3729#issuecomment-419948048):

@fulldecent 

I would shy away from allowing overriding of "external" to "public." (Test 7) Just as you want to disallow overriding of private to internal, I think allowing "external" to "public" is similar. If a contract wants to call an external function, they must do so as an external call, changing the context of the call completely. Allowing external -> public changes the dynamic of the contract a lot. Maybe it's controversial, but I wouldn't allow functions to make more open visibility guarantees, just as I wouldn't allow them to make weaker mutability guarantees! (Same goes for internal -> public - remember the first Parity multisig issue? I feel like that behavior is asking for more of the same)

They may seem different, but mutability and visibility have very complementary effects on a contract IMO. For example:

```
pragma solidity ^0.4.24;
pragma experimental "v0.5.0";

contract Car {
  function accelerate() internal;
}

contract BMW is Car {
  function accelerate() public;
}
```

Car uses `accelerate` as an internal method for speeding up the car, while BMW has decided to make this function public. I would argue that the different access control functions similarly to a change in mutability and should be disallowed.

I would allow:
`public` -> `external`
`internal` -> `private` 

and nothing else. I could also see the logic of pairing visibility modification in inheriting contracts with mutability rules as well. For example,

```
pragma solidity ^0.4.24;
pragma experimental "0.5.0";

interface NonOwnedToken {
    function totalSupply() external view returns (uint256);
}

contract SunshineToken {
    function totalSupply() public view returns (uint256);
}
```

makes sense to me, because it's a `view` function, and we simply want the inheriting contract to be able to access a `view` field. Were the function not `view`, the `public` override allows functionality which was explicitly restricted in the parent.

#### <img src="https://avatars.githubusercontent.com/u/23033765?u=2e7a6d419d3bcf8c495155dad1fd1c7575eab951&v=4" width="50">[maurelian](https://github.com/maurelian) commented at [2018-09-19 21:59](https://github.com/ethereum/solidity/pull/3729#issuecomment-422973030):

@wadeAlexC re: 
> I would shy away from allowing overriding of "external" to "public." (Test 7)

My initial reaction is that that capability should be kept. When implementing a contract from an interface, it is probably not uncommon to decide you want to call a fucntion from the contract. On the other hand, I just generally don't like the `public` keyword, and thing it's uses should be handled by putting an `external` wrapper function around an `internal` function, but I think that might be excessively restrictive.

#### <img src="https://avatars.githubusercontent.com/u/23033765?u=2e7a6d419d3bcf8c495155dad1fd1c7575eab951&v=4" width="50">[maurelian](https://github.com/maurelian) commented at [2018-09-19 22:08](https://github.com/ethereum/solidity/pull/3729#issuecomment-422975059):

My most frequent pain point with inheritance is ambiguity about _"which of these things are actually being deployed"_.

A typical repository might have 30 `contracts`, but only 5 or 6 derived contracts which compile to bytecode that will be deployed. For example, there is no reason to ever deploy a contract which is simply `Ownable`, so why would that be declared as `contract Ownable { ... }`. 

I was impressed with how the 0xProject handled this with a strict naming convention using the terminology of '[Mixins](https://en.wikipedia.org/wiki/Mixin)'. For example, in this [directory](https://github.com/0xProject/0x-monorepo/tree/development/packages/contracts/src/2.0.0/protocol/Exchange), only `Exchange.sol` will be deployed, everything else will be inherited to that contract.

I would like to propose creating a new keyword for declaring an inheritable piece of code. The chief benefit would be a clear indication that _"this is not intended to be a final contract"._ 

Perhaps: `inheritable`, `mixin` or `class`, could be used. The specific word isn't too important. 

Corresponding issue created here: https://github.com/ethereum/solidity/issues/5046

#### <img src="https://avatars.githubusercontent.com/u/9073706?v=4" width="50">[chriseth](https://github.com/chriseth) commented at [2018-09-20 07:51](https://github.com/ethereum/solidity/pull/3729#issuecomment-423078600):

@maurelian we are not yet sure what the best process would be. Recently, we were discussing whether an incremental process across multiple frequent breaking releases would be better than a general overhaul, so perhaps creating an issue is not such a bad idea.

What I would like to get general feedback about is the use of overriding and overloading. My feeling would be that actual overriding (meaning replacing an existing implementation, not merely implementing an interface function) is very uncommon. I think most security issues around inheritance would be solved by disallowing overriding of already implemneted functions unless the base contract's function is marked "virtual" and the derived contract's function is marked "override". Similarly, overloading is only allowed in the same contract and only if all functions with the same name are marked "overload".

#### <img src="https://avatars.githubusercontent.com/u/23033765?u=2e7a6d419d3bcf8c495155dad1fd1c7575eab951&v=4" width="50">[maurelian](https://github.com/maurelian) commented at [2018-09-20 21:05](https://github.com/ethereum/solidity/pull/3729#issuecomment-423333134):

 @chriseth I had to look up the [definitions](https://github.com/ethereum/solidity/pull/3729/files/3339c6137dd3d1e435e9320a04dd532ad763e31f#diff-754689a291c0a19b500c31eb6c1d30c7R834), so I'm placing them here for other's reference:

> * **Overriding:** Declaring two elements (for example functions) of the same name in two different contracts that are part of the same inheritance hierarchy, is called _overriding_. 
> * **Overloading:** Declaring two elements of the same name in the same contract is called _overloading_.

In response to your questions:

> 1. My feeling would be that actual overriding (meaning replacing an existing implementation, not merely implementing an interface function) is very uncommon. I think most security issues around inheritance would be solved by disallowing overriding of already implemented functions unless the base contract's function is marked "virtual" and the derived contract's function is marked "override". 

Unfortunately, I think there are some useful cases for overloading. For example, this [upgrade pattern](https://github.com/bitclave/TokenWrapper/blob/master/contracts/BasicTokenWrapper.sol).

In such cases, I think the `virtual` keyword would require editing the source of the inherited contract, which I really dislike because it breaks a lot of assumptions about how package management should work. 

I'm not sure the solution, but I think the goal is to make it absolutely explicit what source code implements the function. Looking at the [documentation examples](https://solidity.readthedocs.io/en/develop/contracts.html#inheritance), perhaps it could be resolved by: 

1. Creating the `override` keyword you described to alert readers
2. Removing `super` and requiring that all calls explicitly name the source of the inherited contract
3. Disallowing a derived contract with a function naming collision, which doesn't have an `override` implemented. ie. the final example in the documenation would be:

```
contract mortal is owned {
    function kill() public {
        if (msg.sender == owner) selfdestruct(owner);
    }
}

contract Base1 is mortal {
    function kill() public { /* do cleanup 1 */ mortal.kill(); }
}


contract Base2 is mortal {
    function kill() public { /* do cleanup 2 */ mortal.kill(); }
}

contract Final is Base1, Base2 {
    function kill() public override { Base2.kill(); Base1.kill(); }
}
``` 

> 2. Similarly, overloading is only allowed in the same contract, and only if all functions with the same name are marked "overload".

That sounds like a great approach.

#### <img src="https://avatars.githubusercontent.com/u/382183?u=499298f335f6f4f2b2498c3510275590dd8e67fc&v=4" width="50">[fulldecent](https://github.com/fulldecent) commented at [2018-09-21 00:49](https://github.com/ethereum/solidity/pull/3729#issuecomment-423379028):

@chriseth 

The 0xcert ERC721Enumerable implementation uses bona-fide function overrides against the ERC721 baseline implementation:

> https://github.com/0xcert/ethereum-erc721/blob/master/contracts/tokens/NFTokenEnumerable.sol#L120-L136

(The OpenZeppelin version does the same thing.)

* Requiring keyword `overload` for functions that overload, I do not see the necessity here. Does any other language to this? In what way is the currently overloading approach ambiguous or confusing?

---

@wadeAlexC please provide one concrete, non-theoretical example of where overriding an external function with a public function will be bad.

Here is one example where it is good. In ERC721, there is an "ownerOf" function that is publicly exposed. This is also very useful from inside a contract. However, the interface will only ever specify `external`.

---

@maurelian 

* Requiring `override` for functions that override, that's a good idea.
* Requiring `virtual` to allow a function to be overridden. This is similar to "final" versus "open" functions in Swift. I do not support this. The reason that Swift differentiates "final" versus "open" is because they have to worry about run-time virtual lookup tables for "open" functions and it can skip those for "final" functions. We do not have a runtime library so this problem does not apply to us and there is no benefit. Also there is the strong drawback: subclassing is good, even if your parent didn't expect it.
* Disallowing `super.`. I can support `super.`. The inheritance rules make it explicit which contract is referred to by `super.` so it is not ambiguous. Another argument for `super.` is that you inherit `Bob`. You don't care how `Bob` does what it does, so requiring me to find which ancestor of `Bob` implements a specific function is undue burden. If `Bob` refactors its dependency order or moves functions up and down its hierarchy then my code breaks. Now if you are telling me that I can call `Bob.functionxyz` and get any function inherited to `Bob` then now that is useful and follows OOP principle. But you have just reinvented and justified `parent`.

---

Regarding mixins, consider the keyword `abstract`.

```
pragma solidity ^0.5.0;

abstract contract Ownable {
  address public owner;

  // event OwnershipTransferred...

  constructor() public {
    owner = msg.sender;
  }

  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }

  function transferOwnership(address _newOwner) onlyOwner public {
    // ...
  }
}
```

Nobody in their right mind would deploy the `Ownable` contract, even though it is presently possible. The keyword `abstract` removes the ability to compile this contract. And in the Remix IDE, abstract contracts won't even show up as compile targets.

In addition to *allowing* `abstract` keyword to compileable contracts. It is probably helpful to *require* `abstract` for non-compilable contracts. 

```
pragma solidity ^0.4.25;

contract A {
    function x();
}
```

^^^ Presently this code is legal. I propose that it should be an error "Contracts with unimplemented methods must be explicitly marked as `abstract`." Or better, "Contract A must implement function x() or be marked as abstract". And of course, interfaces are implicitly abstract.

#### <img src="https://avatars.githubusercontent.com/u/9073706?v=4" width="50">[chriseth](https://github.com/chriseth) commented at [2018-09-24 11:51](https://github.com/ethereum/solidity/pull/3729#issuecomment-423949029):

Perhaps I'm using slightly different definitions. I'm using overloading as: two functions of the same name but different parameter types. Overriding: Two functions of the same name and same parameter types. Out of two overridden functions, we can select one specifically by prefixing with super or a contract name. Out of two overloaded functions, we always select a specific one just by the types of the arguments we provide.

Note that if we disallow super, then there is no (simple) way to prevent the base function to be called twice in the above example.

I think that the introduction of `virtual` forces you to edit the source of the inherited contract is a good idea, because you will take a look at it again and overriding dramatically changes the semantics of a contract. Take `owned` for example that defines a modifier `onlyOwner` (the same argument can be used for functions). If you know its semantics cannot be changed, you don't have to look at it again. If you know the semantics can be changed, you constantly have to check which semantics are currently in place. Note that overriding applies to every internal call in the base class, too.

#### <img src="https://avatars.githubusercontent.com/u/382183?u=499298f335f6f4f2b2498c3510275590dd8e67fc&v=4" width="50">[fulldecent](https://github.com/fulldecent) commented at [2018-09-24 21:31](https://github.com/ethereum/solidity/pull/3729#issuecomment-424132643):

Editing the base class every time you want to change something is bad. That leads to copy-paste programming and violates DRY.

Designing the base class to understand potential extensions is good and that is resilience.

---

Right now we have two access levels: private and internal, and one modifier but it has two different names (external and public).

---

# Proposal for new access control system

*Borrowed heavily from Swift -- https://docs.swift.org/swift-book/LanguageGuide/AccessControl.html*

Access control levels:

* `private` -- no mangling, child contracts cannot see this function, children can reuse this name
* `internal` (maybe `public`, see below) -- child contracts can use these functions, children may not override these
* `open` -- child contracts can see and override these functions

ABI modifier:

* `external` -- makes a function accessible from the external Ethereum ABI

## Usage

This allows six combinations of functions. Examples are shown for a base contracts have each of the six types:

* `private` (not external) -- children can reuse the name but it has zero impact on the parent
* `private` `external` -- to avoid confusion, we should probably disallow child overriding when it is `private external`. Children can access this through `call` using a new EVM message-call context. Uses `calldata` types. 
* `internal` (not external) -- children cannot override. Children can access from within the contract but not using `call`
* `internal` `external` -- children cannot override. Children can access from within the contract or they can access through `call`.
* `open` (not external) -- children can override the function. The base class and children will use the overriding function (compile-time lookup table) unless the base implementation is specified using `super.` or `ParentClassName`.
* `open` `external` -- same as the not-external version except this can also be accessed externally with `call`.

Interfaces:

This delineation of access control and ABI modifiers has the benefit that interfaces work as-is. Because a `private external`, `internal external` or `open external` implementation is compatible with an `external` function in an `interface`.


## Discussion 

* This `private` usage is inconsistent with Python, see my notes above in the test cases
* Authors of reusable libraries are encouraged to upgrade to `open` when feasible. But without upgrade, the current code will be safe and more restrictive. Pull requests will be opened. We went through the same situation in the Swift world.
* `internal` `external` may sound weird. But an alternative is to do `s/internal/public/g`. This is a backwards-compatibility-breaking change. Previously functions that were `public` will need to become `open` `external` to have the same meaning. I do support making this replacement and using `public` because the word `internal` has a much different meaning in other OOP languages. In EVM, contracts will only talk to each other using `external` interfaces, so it is nice for us to kill one of `internal` or `public`.

#### <img src="https://avatars.githubusercontent.com/u/9073706?v=4" width="50">[chriseth](https://github.com/chriseth) commented at [2018-09-26 14:26](https://github.com/ethereum/solidity/pull/3729#issuecomment-424735972):

This sounds like a good plan. The current confusion also stems from the fact that we allow external and internal function calls and that external functions cannot be called internally, which allows them to have 'calldata' types. Could you also take that into account in your proposal?

#### <img src="https://avatars.githubusercontent.com/u/382183?u=499298f335f6f4f2b2498c3510275590dd8e67fc&v=4" width="50">[fulldecent](https://github.com/fulldecent) commented at [2018-09-27 03:20](https://github.com/ethereum/solidity/pull/3729#issuecomment-424945811):

@chriseth 

For calldata types: so far I only know about:

* `bytes[]` is tightly packed in calldata (and is 32x larger for internal calls) (source https://solidity.readthedocs.io/en/develop/types.html#arrays)

Any more?

Proposal updated for section `private external`.

#### <img src="https://avatars.githubusercontent.com/u/9073706?v=4" width="50">[chriseth](https://github.com/chriseth) commented at [2018-09-27 05:59](https://github.com/ethereum/solidity/pull/3729#issuecomment-424968487):

What i'm mainly aiming at: Currently, you can define functions that can only be accessed externally. If you do, reference types are not copied from calldata to memory and thus it is slightly more efficient, especially if you only process the data and do not store it. Do you propose to remove that feature?

#### <img src="https://avatars.githubusercontent.com/u/382183?u=499298f335f6f4f2b2498c3510275590dd8e67fc&v=4" width="50">[fulldecent](https://github.com/fulldecent) commented at [2018-10-15 16:49](https://github.com/ethereum/solidity/pull/3729#issuecomment-429929442):

@chriseth Yes, I propose to remove that feature. I believe this a compiler detail -- the compiler can decide at compile time if calldata or memory is appropriate for each function based on whether that function is called internally or not.

#### <img src="https://avatars.githubusercontent.com/u/382183?u=499298f335f6f4f2b2498c3510275590dd8e67fc&v=4" width="50">[fulldecent](https://github.com/fulldecent) commented at [2018-10-15 19:44](https://github.com/ethereum/solidity/pull/3729#issuecomment-429987588):

#  ~~ Inheritance Manifesto ~~

- Following is an inheritance system, as explained in documentation that can be directly pasted to https://github.com/ethereum/solidity/blob/develop/docs/contracts.rst
- I can make the PR against contracts.rst
- I can turn this text into a formal specification  la https://github.com/ethereum/solidity/pull/3729#issuecomment-415225557
- I can cross reference that formal specification and documentation into bite-sized issues, also preserving all discussion references and all existing open issues
- I will do these things if there is buy-in from people that are in a position to accept such a change, but also comment from everybody is welcome until that point

# Inheritance and access control system

A contract can inherit functions and variables from another contract. Inheritance enables you to organize your implementation into distinct sections so that each addresses a separate concern, also it promotes code reuse. Likewise, a contract can inherit from an interface and an interface can inherit from another interface.

Contracts in Solidity can call and access functions and variables belonging to the contracts they inherit and can provide their own overriding versions of these functions and variables to refine or modify their behavior. Solidity helps to ensure your overrides are correct by checking that the override definition has a matching inherited definition.

Access control restricts access to a contract's functions and variables from inheriting classes and external (EVM `CALL`) message callers. This feature enables you to hide the implementation details of your code, and to specify a preferred means that functions and variables can be accessed and used.

*Borrowed heavily from Swift -- https://docs.swift.org/swift-book/LanguageGuide/AccessControl.html*

## Contracts

**Synopsis:**

* `function functionName() private`
* `[override] function functionName() [external]`
* `[override] function functionName() open [external]`

**Access control levels:**

These are regarding internal function calls from an inheriting contract, i.e. not using EVM message calls.

* `private`
  *  Callable from within the current contract
  *  Callable from contracts that inherit the current contract
  *  Overridable by contracts that inherit this current contract
  * Note: an inheriting contract may reuse this function name. When calling the function, each contract will use its own implementation.
* internal (implicit default)
  *  Callable from within the current contract
  *  Callable from contracts that inherit the current contract
  *  Overridable by contracts that inherit this current contract
* `open`
  *  Callable from within the current contract
  *  Callable from contracts that inherit the current contract
  *  Overridable by contracts that inherit this current contract
  * Marking a function as `open` explicitly indicates that youve considered the impact of code from other contracts using that function as an override, and that youve designed your contracts code accordingly.


Note: a contract which defines a function without an implementation must mark that function as `open`.

**ABI modifier:**

* `external`
  *  Callable from any contract using EVM message calls
  * Note: a `private` function cannot also be `external`.

**Override modifier:**

* `override`
  * This keyword is required when a contract will override a function from a parent

## Interfaces

Interfaces must mark each function as `external` and must not use the `private` or `open` keywords. The implicit default is that these functions are `open` and are overridable.

An interface may inherit another interface.

Note that the ERC-165 identifier of an interface includes only the items directly in that interface. For an example, please see the identifiers for ERC-721.

## Compatible overrides

An overriding function must accept at least all the inputs that the base function accepts. An overriding function must constrict its outputs at least as strong as the constraints on the base function restricts.

**Examples**

```
pragma solidity ^x.x.x;

contract Food {}

contract DogFood is Food {}

contract Animal {
    function eat(Food meal) open;
    function name() open pure returns (string);
}

contract Dog is Animal {
    override function eat(DogFood meal) public; // ERROR: `Dogfood` is more restrictive than `Food`
    override function name() returns (string); // ERROR: base contract has `pure` constraint, this has weaker guarantee
}
```

**Which version of the function is used?:**

By default, the most derived version of each function is used. For example:

```solidity
pragma solidity ^x.x.x;

contract Printer {
    function favoriteMessage() open returns (string) {
        return "PC LOAD LETTER";
    }
    function print() external returns (string) {
        return favoriteMessage();
    }
}

contract ModernPrinter is Printer {
    override function favoriteMessage() returns pure (string) {
        return "Paper Underflow";
    }
}
```

If you will deploy `ModernPrinter` and call `print()` then the result will be `Paper Underflow`, the modern version!

Alternatively, the contract `Printer` or any inheriting contract may explicitly choose the `Printer` class implementation by calling `Printer.favoriteMessage()`. Lastly, a contract may call its own implementation with `this.favoriteMessage()` or an implementation it inherits from using `super.favoriteMessage()`.

---

# Discussion 

* This `private` usage is inconsistent with Python, see my notes above in the test cases
* Authors of reusable libraries are encouraged to upgrade to `open` when feasible. But without upgrade, the current code will be safe and more restrictive. Pull requests will be opened. We went through the same situation in the Swift world.
* `abstract` is an interesting idea but it is entirely additive, let's not consider that now. Part of the pain point it seeks to address (identifying incomplete contracts) could be addressed downstream in Remix IDE.
* More historical discussion is at Updated proposal based on discussion at https://gitter.im/ethereum/solidity-dev?at=5bc4c63d435c2a518eafe1f9

#### <img src="https://avatars.githubusercontent.com/u/382183?u=499298f335f6f4f2b2498c3510275590dd8e67fc&v=4" width="50">[fulldecent](https://github.com/fulldecent) commented at [2018-10-23 16:56](https://github.com/ethereum/solidity/pull/3729#issuecomment-432330875):

BLOCKER:

- [x] #5293 Document the resiliency of storage usage

PING: 

@chriseth @axic Please review the blocker above. It may cause a problem with my latest proposal. That affects on the private storage variables part of this proposal.

Ignoring the private storage variables part of the proposal, would you please advise if I am green-light to proceed with documentation and test case updates?

I do understand that bite-sized updates are preferred. Upon green-light, I will create a quick summary of bite-sized changes for your review. When approved, I will do the bite sized changes.

#### <img src="https://avatars.githubusercontent.com/u/23033765?u=2e7a6d419d3bcf8c495155dad1fd1c7575eab951&v=4" width="50">[maurelian](https://github.com/maurelian) commented at [2018-10-25 23:30](https://github.com/ethereum/solidity/pull/3729#issuecomment-433238789):

In the above example, I believe it should be `contract ModernPrinter is Printer {`?

#### <img src="https://avatars.githubusercontent.com/u/382183?u=499298f335f6f4f2b2498c3510275590dd8e67fc&v=4" width="50">[fulldecent](https://github.com/fulldecent) commented at [2018-10-26 03:46](https://github.com/ethereum/solidity/pull/3729#issuecomment-433277148):

@maurelian Thank you, updated

#### <img src="https://avatars.githubusercontent.com/u/382183?u=499298f335f6f4f2b2498c3510275590dd8e67fc&v=4" width="50">[fulldecent](https://github.com/fulldecent) commented at [2019-03-02 17:07](https://github.com/ethereum/solidity/pull/3729#issuecomment-468939222):

My latest version updated at https://github.com/ethereum/solidity/pull/3729#issuecomment-429987588. This is a complete version, and I a request your review.

#### <img src="https://avatars.githubusercontent.com/u/382183?u=499298f335f6f4f2b2498c3510275590dd8e67fc&v=4" width="50">[fulldecent](https://github.com/fulldecent) commented at [2019-03-21 04:36](https://github.com/ethereum/solidity/pull/3729#issuecomment-475111111):

One side effect of the inheritance manifesto above is that the `calldata` keyword gets removed because it becomes a compiler detail.

The current approach in 0.5.6 has problems. Here is a concrete example that illustrates this. It compiles with no errors or warnings. The problem is that the developer specifies the location (calldata AND memory) it is undefined behavior where exactly how the compiler will interpret this.

```
pragma solidity ^0.5.6;

interface Animal {
    function eat(string calldata animalFood) external;
}

contract Dog is Animal {
    function eat(string memory animalFood) public {
        // eat it
    }
    
    function liveANormalDay() external {
        eat("Dog food");
        // play();
        eat("More dog food");
    }
}
```

This compiles just the same on current 0.6.0 branch.

#### <img src="https://avatars.githubusercontent.com/u/9073706?v=4" width="50">[chriseth](https://github.com/chriseth) commented at [2019-03-21 09:58](https://github.com/ethereum/solidity/pull/3729#issuecomment-475169263):

I actually don't see the problem in that example.

Note that we are currently leaning towards adding more support for calldata structs and arrays - passing them across internal functions and so on.

#### <img src="https://avatars.githubusercontent.com/u/382183?u=499298f335f6f4f2b2498c3510275590dd8e67fc&v=4" width="50">[fulldecent](https://github.com/fulldecent) commented at [2019-05-30 19:26](https://github.com/ethereum/solidity/pull/3729#issuecomment-497454143):

The problem is that the developer should not care where the memory is stored. The compiler can choose the best option every time. 

Is there any situation where the developer providing this extra information will produce a better compiler output?

#### <img src="https://avatars.githubusercontent.com/u/424752?u=2d50de05ec528b9b84f8b905a56e90669b0f8927&v=4" width="50">[Marenz](https://github.com/Marenz) commented at [2019-11-05 14:02](https://github.com/ethereum/solidity/pull/3729#issuecomment-549835625):

What is the next concrete action to move this PR forward?

#### <img src="https://avatars.githubusercontent.com/u/382183?u=499298f335f6f4f2b2498c3510275590dd8e67fc&v=4" width="50">[fulldecent](https://github.com/fulldecent) commented at [2019-11-06 04:01](https://github.com/ethereum/solidity/pull/3729#issuecomment-550132935):

@Marenz The current status is we have

-  a couple items in this PR
- a manifesto with specifications, that may be an improvement https://github.com/ethereum/solidity/pull/3729#issuecomment-429987588
- other language designs issues https://github.com/ethereum/solidity/issues?utf8=&q=is%3Aopen+author%3Afulldecent+

And we have the following resources:

- Solidity team for some reason wakes up every day and does great stuff
- I can help as a volunteer, usually with language design, specification, and test cases
- The community is generally supportive of languages changes implemented by this project

---

The next concrete actions could be:

1. Solidity team and stakeholders (that's you!) must indicate what level of change is in appetite
2. @chriseth and I could get on the phone (this step saves about 6 months of time)
3. Now I have a clear and nuanced understanding of appetite
4. I write up specification / test cases
5. Consensus is achieved from stakeholders (that's you! and Solidity team)
6.  Solidity team swings bat and hits ball out of park
7. We all go on Stack Overflow to answers questions for the next year if we broke anybody's code

#### <img src="https://avatars.githubusercontent.com/u/424752?u=2d50de05ec528b9b84f8b905a56e90669b0f8927&v=4" width="50">[Marenz](https://github.com/Marenz) commented at [2019-11-06 12:10](https://github.com/ethereum/solidity/pull/3729#issuecomment-550281819):

@fulldecent part of what you're writing is already implemented, namely `override` in our `develop_060` branch, see tracking issue https://github.com/ethereum/solidity/issues/5424 additionally to that `virtual` is currently being added.

#### <img src="https://avatars.githubusercontent.com/u/382183?u=499298f335f6f4f2b2498c3510275590dd8e67fc&v=4" width="50">[fulldecent](https://github.com/fulldecent) commented at [2019-11-08 22:12](https://github.com/ethereum/solidity/pull/3729#issuecomment-552009999):

Cool, thanks for the reference. I have update the Manifesto above to take that into account. And I can do a lot. Just need project buy-in.

#### <img src="https://avatars.githubusercontent.com/u/424752?u=2d50de05ec528b9b84f8b905a56e90669b0f8927&v=4" width="50">[Marenz](https://github.com/Marenz) commented at [2019-11-19 10:54](https://github.com/ethereum/solidity/pull/3729#issuecomment-555452152):

@fulldecent would you like to join our next meeting on Wednesday 15:00 CET? See https://solidity.readthedocs.io/en/latest/contributing.html#team-calls for the details.

#### <img src="https://avatars.githubusercontent.com/u/382183?u=499298f335f6f4f2b2498c3510275590dd8e67fc&v=4" width="50">[fulldecent](https://github.com/fulldecent) commented at [2019-11-20 14:02](https://github.com/ethereum/solidity/pull/3729#issuecomment-556015882):

Thank you yes I will join will be a few minutes late

#### <img src="https://avatars.githubusercontent.com/u/2388185?v=4" width="50">[bshastry](https://github.com/bshastry) commented at [2019-12-02 12:51](https://github.com/ethereum/solidity/pull/3729#issuecomment-560383162):

Summary from the call: @fulldecent plans to open a new manifesto issue after reading up on 0.6.0

#### <img src="https://avatars.githubusercontent.com/u/382183?u=499298f335f6f4f2b2498c3510275590dd8e67fc&v=4" width="50">[fulldecent](https://github.com/fulldecent) commented at [2019-12-02 17:25](https://github.com/ethereum/solidity/pull/3729#issuecomment-560495039):

I have reread all of my comments here, reran the test cases on 0.6.0 (at e34997339625ce5c087daa7b03672e7f8c94c721) and compared.

Every language design issue is resolved by 0.6.0.

* Overriding a function with incompatible inputs now fails
* Overriding a function with incompatible outputs now fails
* Functions now require new markup to be overriden
* Great discussion at https://gitter.im/ethereum/solidity-dev?at=5bc4c63d435c2a518eafe1f9 all items addressed

No further actionable language design items remain in this thread.

Some of the things above could be valuable for documentation. I will check up to see what can be added. Otherwise, all done. The manifesto was a success. No new manifesto is needed now.

#### <img src="https://avatars.githubusercontent.com/u/2388185?v=4" width="50">[bshastry](https://github.com/bshastry) commented at [2019-12-02 17:32](https://github.com/ethereum/solidity/pull/3729#issuecomment-560497796):

Thank you for the update @fulldecent


-------------------------------------------------------------------------------



[Export of Github issue for [ethereum/solidity](https://github.com/ethereum/solidity). Generated on 2024.12.15 at 06:45:24.]
