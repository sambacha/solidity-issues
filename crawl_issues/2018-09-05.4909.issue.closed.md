# [\#4909 Issue](https://github.com/ethereum/solidity/issues/4909) `closed`: memory can be freed somehow

#### <img src="https://avatars.githubusercontent.com/u/1409883?u=1f49863b1110007dee59da22e445c97f4cb93ffc&v=4" width="50">[liangdzou](https://github.com/liangdzou) opened issue at [2018-09-05 12:05](https://github.com/ethereum/solidity/issues/4909):

IMHO, the functions that return memory reference cannot reset the free memory pointer. This is known statically, so, we can insert those instructions for the functions that do not return memory references. Even if one function returns memory reference, the memory can be freed by the first ancestor that does not return memory reference. I think this will also help to save some gas.

By the way, can we implement the returned memory by allocating the memory by its parent an pass by reference?

**The following is copied from issue #4881. I did not find a way to open it. I still have some idea to discuss. so, I have to create a new one. Sorry for the inconvenient caused.**

## Abstract

Write a simple example as follows.
```
  1 pragma solidity ^0.4.15;                                                        
  2 contract Hello {                                                                
  3   function f() public {                                                         
  4     int[10] memory x;                                                                                                                                                                                                                                                     
  5   }                                                                             
  6 }                                                                               
```
I only found one place changes the "free memory pointer" in the generated ASM.

```
 81       0x140
 82       mload(0x40)                                                               
 83       swap1                                                                     
 84       dup2                                                                      
 85       add                                                                       
 86       0x40                                                                      
 87       mstore                                                                    
```

So, the memory is never freed.
This can be fixed by insert "mload" at the beginning of a function call and "mstore" at the end of the function call.

## Motivation

Currently, Solidity does not free memory automatically. I have tried a few examples, the ASM code generated by Solidity never subtracts the "free memory pointer" in memory location 0x40. This can be fixed by insert two instructions.

## Specification

Insert one instruction "mload 0x40" at the beginning of a function call and store it back to "free memory pointer" by "mstore 0x40 value".
The cost is very low and actually can save lots of memory. I think at least this can be an optimization option.

## Backwards Compatibility

This change does not bring any backwards compatibility problem.

#### <img src="https://avatars.githubusercontent.com/u/9073706?v=4" width="50">[chriseth](https://github.com/chriseth) commented at [2018-09-05 12:16](https://github.com/ethereum/solidity/issues/4909#issuecomment-418708768):

Thanks for the additional input. I still don't see many use-cases of local memory variables that are neither passed in nor out of a function, because that would be the only place where we could free the memory easily.

#### <img src="https://avatars.githubusercontent.com/u/1409883?u=1f49863b1110007dee59da22e445c97f4cb93ffc&v=4" width="50">[liangdzou](https://github.com/liangdzou) commented at [2018-09-05 16:12](https://github.com/ethereum/solidity/issues/4909#issuecomment-418789367):

I think it is easier to free the memory if there is no memory passed between functions. If there is no memory passed between functions, the memory allocated in the function will never be used after the function call instance is finished. Next time, when the function is called again, the memory will be allocated again. (correct me if I am wrong.) I think the only way to reuse a memory in Solidity is by passing by reference.

#### <img src="https://avatars.githubusercontent.com/u/1409883?u=1f49863b1110007dee59da22e445c97f4cb93ffc&v=4" width="50">[liangdzou](https://github.com/liangdzou) commented at [2018-09-06 16:51](https://github.com/ethereum/solidity/issues/4909#issuecomment-419165260):

Yeah, this seems not so important since all smart contracts are gas limited. When a smart contract is finished the EVM instance is freed which cause all the memory is freed.


-------------------------------------------------------------------------------



[Export of Github issue for [ethereum/solidity](https://github.com/ethereum/solidity). Generated on 2024.12.15 at 06:45:24.]
