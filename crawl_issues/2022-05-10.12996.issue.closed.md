# [\#12996 Issue](https://github.com/ethereum/solidity/issues/12996) `closed`: Language feature: disallow state-changing effects after an external call by default
**Labels**: `breaking change :warning:`, `language design :rage4:`, `medium effort`, `high impact`, `needs design`


#### <img src="https://avatars.githubusercontent.com/u/25297591?u=3251a9019e72f66e32ba31d57729796ad505c530&v=4" width="50">[pcaversaccio](https://github.com/pcaversaccio) opened issue at [2022-05-10 08:08](https://github.com/ethereum/solidity/issues/12996):

## Abstract

Generally disallowing state-changing effects after an `external` function call and enabling the possibility to mark functions that specifically do this.

## Motivation

I started this discussion on [Twitter](https://twitter.com/pcaversaccio/status/1523231260721975296) after another reentrancy attack (Cc: @chriseth). Reentrancy attacks are ubiquitous and even though there are toolings available (e.g. Slither) that conduct a static analysis it requires an initial setup as well as a proper understanding of how to interpret the results. In order to make the Solidity development more secure and sustainable I feel it's time to finally introduce such a language feature that disallows state-changing effects after an `external` function call and mark functions that specifically do this.

## Specification

All state-changing effects after an `external` function call are disallowed. If you want to allow however such a possibility, we introduce a new modifier `unprotected` whose default value is `false`.

## Backwards Compatibility

The code that previously compiled fine will not compile anymore if there is a state-change effect after an `external` call and the new modifier `unprotected` is unknown, so it's a breaking change.



#### <img src="https://avatars.githubusercontent.com/u/9073706?v=4" width="50">[chriseth](https://github.com/chriseth) commented at [2022-05-10 08:32](https://github.com/ethereum/solidity/issues/12996#issuecomment-1122093106):

Just a comment on the name of the modifier: I don't like opinionated words like "safe" or "protected" because they give a false impression of safety or protection, we should find a more neutral one.

Also more generally: Also wrt. free functions, it might be a good idea to explicitly pass/provide something like a "context" as a parameter to functions that allows external calls (or maybe even state changes without external calls). In this case, we could have a special property on this context that allows state changes after an external call. By default, the context would transform into a "constant state" context after an external call - there are the linear types again.

Also something to consider more specifically to this issue: Is it OK to do another external call after the first external call? What about a delegatecall? Even if we do not use delegatecall, how do we distinguish a "data contract" that is associated to the current contract from a potentially malicious external contract?

After all these questions, I'm more and more inclined that this should rather be "off-loaded" to user code and the compiler should instead provide the required features for the type system.

#### <img src="https://avatars.githubusercontent.com/u/25297591?u=3251a9019e72f66e32ba31d57729796ad505c530&v=4" width="50">[pcaversaccio](https://github.com/pcaversaccio) commented at [2022-05-10 20:58](https://github.com/ethereum/solidity/issues/12996#issuecomment-1122854036):

You are right about the name of the modifier - after thinking through it today maybe we even do not need a modifier but can use the `unchecked` block syntax directly. I think in a _broader sense_ this language feature is consistent with the checked arithmetic introduced in solc version `0.8.0` since it also wants to prevent unwanted behaviour that could be exploited (one of the major reasons behind introducing libraries such as `SafeMath` were smart contract exploits based on overflow/underflow vulnerabilities).

There are three types of reentrancy:
- Single Function Reentrancy
- Cross-Function Reentrancy
- Cross-Contract Reentrancy

For the cross-contract reentrancy, this one can happen when a state from one contract is used in another contract, but that state is not fully updated before getting called.

The conditions required for the cross-contract reentrancy to be possible are as follows:
- The execution flow can be controlled by the attacker to manipulate the contract state.
- The value of the state in the contract is shared or used in another contract.

The best outcome for this language feature would be that one could write the contracts without bothering about these three types by _default_. Of course, we can always argue to "offload" all the responsibility to the developers but past experience and events showcase blatantly that this does not work as intended.

Coming back to your context idea - I really like it but couldn't we simply achieve that via the `unchecked` block syntax. I.e. an `unchecked` block does not only _not_ control for an unrestricted integer that falls outside the range of the result type but also allows for a "non-constant state". By default, however, the context is a "constant state".

> Also something to consider more specifically to this issue: Is it OK to do another external call after the first external call? What about a delegatecall? Even if we do not use delegatecall, how do we distinguish a "data contract" that is associated to the current contract from a potentially malicious external contract?

I'm not yet sure what would be the best design here tbh.

#### <img src="https://avatars.githubusercontent.com/u/25297591?u=3251a9019e72f66e32ba31d57729796ad505c530&v=4" width="50">[pcaversaccio](https://github.com/pcaversaccio) commented at [2022-05-17 13:42](https://github.com/ethereum/solidity/issues/12996#issuecomment-1128887596):

I would like to quickly add some further thoughts behind this language feature: The main question is whether we should build the language in a _via negativa_ or _via positiva_ way. I strongly tend based on the experience and events over the last 6 years to the first one. If you look at all the exploits that happened over the last 6 years (including DAO) we haven't got really smarter w.r.t. to reentrancy attacks as it seems (I also blame a little bit the auditors who push for the low-level calls instead e.g. transfer). Too many devs are still not paranoid enough! And Solidity already started implementing such safety features via `unchecked` for over/underflows. It's definitely a tradeoff here and my reasoning is practice-driven.

#### <img src="https://avatars.githubusercontent.com/u/25297591?u=3251a9019e72f66e32ba31d57729796ad505c530&v=4" width="50">[pcaversaccio](https://github.com/pcaversaccio) commented at [2022-06-08 07:47](https://github.com/ethereum/solidity/issues/12996#issuecomment-1149579731):

@cameel @hrkrshnn what are your opinions on my thoughts here?

#### <img src="https://avatars.githubusercontent.com/u/504195?u=ce2facd14af9fd474ebff49f0d44891f56f7500f&v=4" width="50">[leonardoalt](https://github.com/leonardoalt) commented at [2022-07-04 09:00](https://github.com/ethereum/solidity/issues/12996#issuecomment-1173550008):

I think this shouldn't go into the language with `safe/protected` keywords and such, and should rather have similar behavior as checked arithmetic.

IMO, reentrancy guards could be added by default for every external call, and bypassed if the call is in an `unchecked` block. This also follows Rust's `unsafe` style which seems popular.

#### <img src="https://avatars.githubusercontent.com/u/504195?u=ce2facd14af9fd474ebff49f0d44891f56f7500f&v=4" width="50">[leonardoalt](https://github.com/leonardoalt) commented at [2022-07-04 09:07](https://github.com/ethereum/solidity/issues/12996#issuecomment-1173557794):

https://github.com/ethereum/solidity/issues/13124 is a dup of this issue in general but offers two different approaches:

- Aggressive: basically what I said above
- Conservative: try to detect whether state changes are performed after external calls, and if yes add the reentrancy guards.

Copying what I said in the other issue:

You could combine both approaches, eg have the aggressive approach by default which can be bypassed by the user if the external call is in an unchecked block, and the compiler can also choose to optimize it away if it detects the conditions in the conservative approach.

#### <img src="https://avatars.githubusercontent.com/u/811305?u=b2a7f87d77c4fd8a388b45691c92912df24ea6e1&v=4" width="50">[lukehutch](https://github.com/lukehutch) commented at [2022-07-04 10:16](https://github.com/ethereum/solidity/issues/12996#issuecomment-1173634143):

Standard reachability analysis should be able to determine quite easily whether any given line can modify state or call a function in another contract. Then Solidity just needs to ensure that every function has a partition between state modification first, and external calls second.

If you want the user to have to explicitly signify whether a function updates state, you already have that: non-`pure`/`view`. If you want the user to have to explicitly signify which functions can call other contracts, you could add a `caller` modifier or something. Then you could not call a state modifier function or modify state after a `caller` function or an `address.call` within any function -- and any function that calls a `caller` function or calls `address.call` also itself becomes a `caller` function.

#### <img src="https://avatars.githubusercontent.com/u/504195?u=ce2facd14af9fd474ebff49f0d44891f56f7500f&v=4" width="50">[leonardoalt](https://github.com/leonardoalt) commented at [2022-07-04 10:23](https://github.com/ethereum/solidity/issues/12996#issuecomment-1173641610):

I personally really dislike the idea of function modifiers for reentrancy. It's too binary and does not represent the amount of different use cases. Moreover:

- the strategy you mention first can yield false positives for safe cases that do not conform exactly to this pattern
- I understand your second paragraph but it sounds really confusing. Imagine documenting/implementing this, it's gonna be full of edge cases and potentially make the analysis more dangerous/confusing.

Edit:

- I'm not against the reachability analysis. I think it is useful as an optimization for cases that are safe for sure.
- I just think the simplest would be to add a guard to every call by default with the possibility of removing it. No extra keyword, no complicated analysis besides the optimization above, no edge cases. Plus it conforms to a standard that the language already has.

#### <img src="https://avatars.githubusercontent.com/u/811305?u=b2a7f87d77c4fd8a388b45691c92912df24ea6e1&v=4" width="50">[lukehutch](https://github.com/lukehutch) commented at [2022-07-04 10:29](https://github.com/ethereum/solidity/issues/12996#issuecomment-1173648701):

What I proposed is already basically what Slither does (minus the modifiers), but Solidity should give these warnings rather than Slither, because this is such a serious source of security vulnerabilities.

Yes, in the general case precise reachability analysis is uncomputable, unless you use conservative logic that looks to see whether something *might* be reachable given some specific runtime control flow (then reachability analysis becomes simple and computable).

Re. the modifiers, there's a reason why Solidity made visibility modifiers and mutation modifiers required a few versions ago. Being explicit establishes a contract between the programmer and the compiler. And what I explained in my 2nd paragraph is exactly what Solidity already does (albeit with inverted logic) with mutation modifiers for pure/view functions. So basically the machinery is all already there in the compiler to implement this simply.

#### <img src="https://avatars.githubusercontent.com/u/811305?u=b2a7f87d77c4fd8a388b45691c92912df24ea6e1&v=4" width="50">[lukehutch](https://github.com/lukehutch) commented at [2022-07-16 20:54](https://github.com/ethereum/solidity/issues/12996#issuecomment-1186290000):

It will be much easier to implement robust automatic runtime protections against reentrancy attacks at runtime once [EIP-1153](https://eips.ethereum.org/EIPS/eip-1153) is merged, because it will allow for flags to be set whose lifecycle is bound to a transaction.

However, I believe the vast majority of reentrancy attack vulnerabilities can be detected and prevented through static analysis.

#### <img src="https://avatars.githubusercontent.com/u/504195?u=ce2facd14af9fd474ebff49f0d44891f56f7500f&v=4" width="50">[leonardoalt](https://github.com/leonardoalt) commented at [2022-07-17 08:23](https://github.com/ethereum/solidity/issues/12996#issuecomment-1186443428):

> It will be much easier to implement robust automatic runtime protections against reentrancy attacks at runtime once [EIP-1153](https://eips.ethereum.org/EIPS/eip-1153) is merged, because it will allow for flags to be set whose lifecycle is bound to a transaction.

Are you confident that's gonna go in? I personally am not.

> However, I believe the vast majority of reentrancy attack vulnerabilities can be detected and prevented through static analysis.

Agree that potential reentrancy can be detected with syntactic static analysis. But what about false positives?

I think there are multiple ideas here that are complementary and provide different levels of safety and user experience. We need to get more people into this discussion, not only from the team. We also need to gather actual data on how many / what type of contracts would benefit from each proposed solution, and how many would be made worse / more annoying.

#### <img src="https://avatars.githubusercontent.com/u/25297591?u=3251a9019e72f66e32ba31d57729796ad505c530&v=4" width="50">[pcaversaccio](https://github.com/pcaversaccio) commented at [2022-07-18 13:09](https://github.com/ethereum/solidity/issues/12996#issuecomment-1187381059):

As quickly discussed with @leonardoalt it would be good to compile a list of reentrancy attacks and to understand what kind of code design pattern would fit best. Also, IMHO we should not rely on EIP-1153 to be finalised and implemented soon - let's take the current status quo of the EVM and solc as the valid principles for the solution-finding process. Furthermore, I also think we need to be careful to jump to conclusions too fast. Past code patterns should not necessarily imply what future code patterns will look like (also wrt what is planned for e.g. solc `0.9.0`). Maybe to some extent, engineers must "unlearn" certain design patterns for the greater good.

Let me try to share a common, chronological list of reentrancy attacks including their (mostly) detailed analyses:

- [WETH white hat attack](https://github.com/pcaversaccio/reentrancy-attacks/issues/1#issuecomment-1188680199) – 10 June 2016 | [Victim contract](https://etherscan.io/address/0xd654bDD32FC99471455e86C2E7f7D7b6437e9179), [Exploit contract](https://etherscan.io/address/0x4AfB544Eb87265cF7Fc8fdB843c81d34F7E2A369), [Exploit transaction](https://etherscan.io/tx/0x8d8404d056607815c04dd286858da123c6e6aea29a1197e21a803fa67ebedd7c)
- [The DAO attack](https://medium.com/@zhongqiangc/smart-contract-reentrancy-thedao-f2da1d25180c) – 17 June 2016 | [Victim contract](https://etherscan.io/address/0xBB9bc244D798123fDe783fCc1C72d3Bb8C189413), [Exploit contract](https://etherscan.io/address/0xC0ee9dB1a9E07cA63E4fF0d5FB6F86Bf68D47b89), [Exploit transaction](https://etherscan.io/tx/0x0ec3f2488a93839524add10ea229e773f6bc891b4eb4794c3337d4495263790b)
- [SpankChain attack](https://medium.com/swlh/how-spankchain-got-hacked-af65b933393c) – 9 October 2018 | [Victim contract](https://etherscan.io/address/0xf91546835f756DA0c10cFa0CDA95b15577b84aA7), [Exploit contract](https://etherscan.io/address/0xc5918a927C4FB83FE99E30d6F66707F4b396900E), [Exploit transaction](https://etherscan.io/tx/0x21e9d20b57f6ae60dac23466c8395d47f42dc24628e5a31f224567a2b4effa88)
- [imBTC Uniswap pool attack](https://defirate.com/imbtc-uniswap-hack) – 18 April 2020 | [Victim contract](https://etherscan.io/address/0xFFcf45b540e6C9F094Ae656D2e34aD11cdfdb187), [Exploit contract](https://etherscan.io/address/0xBD2250D713bf98b7E00c26E2907370aD30f0891a), [Exploit transaction](https://etherscan.io/tx/0x9437dde6c06a20f6d56f69b07f43d5fb918e6c57c97e1fc25a4162c693f578aa)
- [Lendf.Me attack](https://slowmist.medium.com/slowmist-details-of-lendf-me-reentrancy-attack-3e168ab5f2b1) – 19 April 2020 | [Victim contract](https://etherscan.io/address/0x0eEe3E3828A45f7601D5F54bF49bB01d1A9dF5ea), [Exploit contract](https://etherscan.io/address/0x538359785a8D5AB1A741A0bA94f26a800759D91D), [Exploit transaction](https://etherscan.io/tx/0xced7ca813081fb594181469001a6aff629c5874bd672cca44075d3ec768db664)
- [Akropolis attack](https://peckshield.medium.com/akropolis-incident-root-cause-analysis-c11ee59e05d4) – 12 November 2020 | [Victim contract](https://etherscan.io/address/0x73fC3038B4cD8FfD07482b92a52Ea806505e5748), [Exploit contract](https://etherscan.io/address/0xe2307837524Db8961C4541f943598654240bd62f), [Exploit transaction](https://etherscan.io/tx/0xe1f375a47172b5612d96496a4599247049f07c9a7d518929fbe296b0c281e04d)
- [ValueDeFi attack](https://inspexco.medium.com/value-defis-invalid-share-calculation-exploit-in-depth-analysis-1c8f97c1416e) – 7 May 2021 | [Victim contract](https://bscscan.com/address/0xD4BBF439d3EAb5155Ca7c0537E583088fB4CFCe8), [Exploit contract](https://bscscan.com/address/0x4269e4090FF9dFc99D8846eB0D42E67F01C3AC8b), [Exploit transaction](https://bscscan.com/tx/0x9dab872598ee7a6290ed7d6f3a903f44a8794246c3089cc91d6cfb69be4d58b4)
- [Rari Capital attack](https://nipunp.medium.com/5-8-21-rari-capital-exploit-timeline-analysis-8beda31cbc1a) – 8 May 2021 | [Victim contract](https://etherscan.io/address/0x67B66C99D3Eb37Fa76Aa3Ed1ff33E8e39F0b9c7A), [Exploit contract](https://etherscan.io/address/0x2f755e8980f0c2E81681D82CCCd1a4BD5b4D5D46), [Exploit transaction](https://etherscan.io/tx/0x1655592eda3ebbba7c530ab3327daeae95fa95d05c3dec40338471245da10cfe)
- [BurgerSwap attack](https://quillhashteam.medium.com/burgerswap-flash-loan-attack-analysis-888b1911daef) – 27 May 2021 | [Victim contract](https://bscscan.com/address/0x7ac55ac530f2C29659573Bde0700c6758D69e677), [Exploit contract](https://bscscan.com/address/0xAE0F538409063e66ff0E382113cb1a051fC069cd), [Exploit transaction](https://bscscan.com/tx/0xac8a739c1f668b13d065d56a03c37a686e0aa1c9339e79fcbc5a2d0a6311e333)
- [Iron Finance attack](https://thedefiant.io/not-just-a-bank-run-new-evidence-shows-iron-finance-crashed-due-to-code-exploit) – 16 June 2021 | [Victim contract](https://polygonscan.com/address/0xa37DD1f62661EB18c338f18Cf797cff8b5102d8e), [Exploit contract](https://polygonscan.com/address/0x9E0bB84c39227755b76e286665f0a2B0bD3Bcc96), [Exploit transaction](https://polygonscan.com/tx/0x05d5c121251cb7cea91a89aaa164451639acb328b4a0a8001470aea531d77a7a)
- [PolyDEX attack](https://polydex.medium.com/plx-locker-smart-contract-incident-post-mortem-75342124a3e8) – 20 June 2021 | [Victim contract](https://polygonscan.com/address/0x28151Ba48963019ddB509FbB6D5761F3494b3828), [Exploit contract](https://polygonscan.com/address/0x287F8Cf077666e60e2d238bF77a525051481D769), [Exploit transaction](https://polygonscan.com/tx/0x6b3f057683083d7f0a25e4d3898ca68308cfe2335878143466f84b3003ebe3a2)
- [DeFiPie attack](https://medium.com/defipie/hacking-investigation-85e07454f1c9) – 12 July 2021 | [Victim contract](https://bscscan.com/address/0xd6eAC7cf547002d289dC85954Ec0ABE217A9b80D), [Exploit contract](https://bscscan.com/address/0x6d741523F1FcBa87Bb8ddA1Ab85D765a9544E6a6), [Exploit transaction](https://bscscan.com/tx/0x45f6f792638d114f31f6608dca4c79b1216bd5c7c45218a5fd8f1c2e309c6d75)
- [Sanshu Inu attack](https://sanshunft.medium.com/woofdate-2-2-0-keanu-compensation-mfund-rebase-update-bcac09707e19) – 20 July 2021 | [Victim contract](https://etherscan.io/address/0x35C674C288577Df3e9b5dafEF945795b741c7810), [Exploit contract](https://etherscan.io/address/0xe30DC9B3c29534E9b4e9A166c2f44411163aD59F), [Exploit transaction](https://etherscan.io/tx/0x00edd68087ee372a1b6e05249cc6c992bb7b8478cc0ddc70c2a1453428285808)
- [XSURGE attack](https://medium.com/@Knownsec_Blockchain_Lab/knownsec-blockchain-lab-comprehensive-analysis-of-xsurge-attacks-c83d238fbc55) – 16 August 2021 | [Victim contract](https://www.bscscan.com/address/0xE1E1Aa58983F6b8eE8E4eCD206ceA6578F036c21), [Exploit contract](https://www.bscscan.com/address/0x1514AAA4dCF56c4Aa90da6a4ed19118E6800dc46), [Exploit transaction](https://www.bscscan.com/tx/0x7e2a6ec08464e8e0118368cb933dc64ed9ce36445ecf9c49cacb970ea78531d2)
- [C.R.E.A.M. Finance attack](https://inspexco.medium.com/reentrancy-attack-on-cream-finance-incident-analysis-1c629686b6f5) – 30 August 2021 | [Victim contract](https://etherscan.io/address/0xD06527D5e56A3495252A528C4987003b712860eE), [Exploit contract](https://etherscan.io/address/0x2E95B91FA678b47660aBA811B74a28Ca1F4ED111), [Exploit transaction](https://etherscan.io/tx/0xd7ec3046ec75efbd04b3eea8752a8a6373a92c0dd813d08b655661054d3239c5)
- [Siren Protocol attack](https://web.archive.org/web/20221215032356/https://medium.com/siren/siren-incident-report-264e57f16d7)[^1] – 3 September 2021 | [Victim contract](https://polygonscan.com/address/0xC3F7250f458E86a4BD19D0819550aC0b17902BdC), [Exploit contract](https://polygonscan.com/address/0x685b121BBB80E89c232f0Ea1755794F14CfC9822), [Exploit transaction](https://polygonscan.com/tx/0xf95fd54b4b1ed0bc109a04df16d1d75106a4d007b186543467c975df94cd3276)
- [CreatureToadz attack](https://medium.com/@ItsCuzzo/exploitedtoadz-a-technical-deepdive-9ceabf46d0ce) – 21 October 2021 | [Victim contract](https://etherscan.io/address/0xA4631A191044096834Ce65d1EE86b16b171D8080), [Exploit contract](https://etherscan.io/address/0xdFF832F6988E4a9E3FCfBfF4cc24d052143aba0E), [Exploit transaction](https://etherscan.io/tx/0x125581f9551c0ae1098e132823cd5cffc0c942be4e6fed6cd447bde017e87130)
- [Grim Finance attack](https://rekt.news/grim-finance-rekt) – 18 December 2021 | [Victim contract](https://ftmscan.com/address/0x660184CE8AF80e0B1e5A1172A16168b15f4136bF), [Exploit contract](https://ftmscan.com/address/0xb08cCb39741d746Dd1818641900f182448Eb5e41), [Exploit transaction](https://ftmscan.com/tx/0x19315e5b150d0a83e797203bb9c957ec1fa8a6f404f4f761d970cb29a74a5dd6)
- [Visor Finance attack](https://sharkteam.org/report/analysis/20211223001A_en.pdf) – 21 December 2021 | [Victim contract](https://etherscan.io/address/0x3a84aD5d16aDBE566BAA6b3DafE39Db3D5E261E5), [Exploit contract](https://etherscan.io/address/0x10C509AA9ab291C76c45414e7CdBd375e1D5AcE8), [Exploit transaction](https://etherscan.io/tx/0x69272d8c84d67d1da2f6425b339192fa472898dce936f24818fda415c1c1ff3f)
- [HypeBears attack](https://blocksecteam.medium.com/when-safemint-becomes-unsafe-lessons-from-the-hypebears-security-incident-2965209bda2a) – 3 February 2022 | [Victim contract](https://etherscan.io/address/0x14e0a1F310E2B7E321c91f58847e98b8C802f6eF), [Exploit contract](https://etherscan.io/address/0x49AB6aBd4be00Df45E5C8e8949Dd41389c34A704), [Exploit transaction](https://etherscan.io/tx/0xfa97c3476aa8aeac662dae0cc3f0d3da48472ff4e7c55d0e305901ec37a2f704)
- [Bacon Protocol attack](https://coincodecap.com/bacon-protocol-hacked-reportedly-1m-lost) – 5 March 2022 | [Victim contract](https://etherscan.io/address/0xb8919522331C59f5C16bDfAA6A121a6E03A91F62), [Exploit contract](https://etherscan.io/address/0x580CaC65C2620D194371ef29Eb887A7D8DCc91Bf), [Exploit transaction](https://etherscan.io/tx/0x7d2296bcb936aa5e2397ddf8ccba59f54a178c3901666b49291d880369dbcf31)
- [Paraluni attack](https://coincodecap.com/paraluni-hacked-reportedly-1-7m-lost) – 13 March 2022 | [Victim contract](https://bscscan.com/address/0x633Fa755a83B015cCcDc451F82C57EA0Bd32b4B4), [Exploit contract](https://www.bscscan.com/address/0x4770b5cb9d51EcB7AD5B14f0d4F2cEe8e5563645), [Exploit transaction](https://www.bscscan.com/tx/0x70f367b9420ac2654a5223cc311c7f9c361736a39fd4e7dff9ed1b85bab7ad54)
- [Agave Finance attack](https://twitter.com/Mudit__Gupta/status/1503783633877827586) – 15 March 2022 | [Victim contract](https://gnosisscan.io/address/0x95a21fCbb57ed54D3a5a706068b06cEE8637998a), [Exploit contract](https://gnosisscan.io/address/0xF98169301B06e906AF7f9b719204AA10D1F160d6), [Exploit transaction](https://gnosisscan.io/tx/0xa262141abcf7c127b88b4042aee8bf601f4f3372c9471dbd75cb54e76524f18e)
- [Hundred Finance attack](https://slowmist.medium.com/another-day-another-reentrancy-attack-5cde10bbb2b4) – 15 March 2022 | [Victim contract](https://gnosisscan.io/address/0x8e15a22853A0A60a0FBB0d875055A8E66cff0235), [Exploit contract](https://gnosisscan.io/address/0xdbf225e3d626ec31f502d435b0f72d82b08e1bdd), [Exploit transaction](https://gnosisscan.io/tx/0x534b84f657883ddc1b66a314e8b392feb35024afdec61dfe8e7c510cfac1a098)
- [Revest Finance attack](https://slowmist.medium.com/revest-finance-incident-analysis-6fcd9b6be207) – 27 March 2022 | [Victim contract](https://etherscan.io/address/0x2320A28f52334d62622cc2EaFa15DE55F9987eD9), [Exploit contract](https://etherscan.io/address/0xb480Ac726528D1c195cD3bb32F19C92E8d928519), [Exploit transaction](https://etherscan.io/tx/0xe0b0c2672b760bef4e2851e91c69c8c0ad135c6987bbf1f43f5846d89e691428)
- [Voltage Finance attack](https://rekt.news/voltage-finance-rekt) – 31 March 2022 | [Victim contract](https://explorer.fuse.io/address/0xa722c13135930332Eb3d749B2F0906559D2C5b99), [Exploit contract](https://explorer.fuse.io/address/0x632942c9BeF1a1127353E1b99e817651e2390CFF), [Exploit transaction](https://explorer.fuse.io/tx/0x1b3e06b6b310886dfd90a5df8ddbaf515750eda7126cf5f69874e92761b1dc90/token-transfers)
- [BNB Brokers attack](https://twitter.com/BlockSecTeam/status/1519249933832171520) – 27 April 2022 | [Victim contract](https://bscscan.com/address/0x2C67f86D91BA3cA559c6d2825d9dbD00C5A90e4B), [Exploit contract](https://bscscan.com/address/0x02C05Ed9e8fda290ba88225eaDce4146Bde7C80A), [Exploit transaction](https://bscscan.com/tx/0x74907b06cacbe77a5af64f8cc16ff49ff7fefc672c5d68909637caa7f9466dca)
- [Fei Protocol attack](https://certik.medium.com/fei-protocol-incident-analysis-8527440696cc) – 30 April 2022 | [Victim contract](https://etherscan.io/address/0x26267e41CeCa7C8E0f143554Af707336f27Fa051), [Exploit contract](https://etherscan.io/address/0x32075bAd9050d4767018084F0Cb87b3182D36C45), [Exploit transaction](https://etherscan.io/tx/0xadbe5cf9269a001d50990d0c29075b402bcc3a0b0f3258821881621b787b35c6)
- [Bistroo attack](https://bistroo.medium.com/post-incident-review-bist-single-asset-staking-binancesmartchain-security-breach-5194590605f) – 7 May 2022 | [Victim contract](https://www.bscscan.com/address/0x2987B3983bfA7E2698b4C10A361ca5119697a080), [Exploit contract](https://bscscan.com/address/0x70B31bB9859E88ddb3Ac04bc205575992EdAd3FA), [Exploit transaction](https://bscscan.com/tx/0x8c96b3314e30cf62bdfd4f94df38a2f040e171e849208b328dcd4ac2cdbcb748)
- [Ownly attack](https://twitter.com/ownlyio/status/1524362090940895234) – 10 May 2022 | [Victim contract](https://www.bscscan.com/address/0x421f30419D6c1D7573C1F57546A631f2f89D7E92), [Exploit contract](https://www.bscscan.com/address/0xA81eA095e0c3708E4236c71146748FA15B620386), [Exploit transaction](https://www.bscscan.com/tx/0x2cbe47edb040c710b7f139cbea7a4bced4d6a0d6c5aa4380f445880437ea072f)
- [Omni attack](https://twitter.com/BlockSecTeam/status/1546141457933025280) – 10 July 2022 | [Victim contract](https://etherscan.io/address/0x2F131C4DAd4Be81683ABb966b4DE05a549144443), [Exploit contract](https://etherscan.io/address/0x3C10E78343c475b99d20fA544dd30b43C0cBa26f), [Exploit transaction](https://etherscan.io/tx/0x264e16f4862d182a6a0b74977df28a85747b6f237b5e229c9a5bbacdf499ccb4)
- [Stader Labs NearX attack](https://medium.com/quillhash/decoding-a-830-000-exploit-quillaudits-c70d1ecfd562) – 16 August 2022 | [Victim contract](https://nearblocks.io/address/nearx.stader-labs.near), [Exploit contract](https://nearblocks.io/address/gregoshes.near)[^2], [Exploit transaction](https://nearblocks.io/txns/BexQuhmdtr745g5fSqvVnCDvXCms14XFJXAZPKWzFc4o)
- [Thunder Brawl attack](https://twitter.com/peckshield/status/1575890733373849601) – 30 September 2022 | [Victim contract](https://bscscan.com/address/0xae191Ca19F0f8E21d754c6CAb99107eD62B6fe53), [Exploit contract](https://bscscan.com/address/0xfeD1B640633Fd0A4d77315d229918ab1f6E612f9), [Exploit transaction](https://bscscan.com/tx/0x57aa9c85e03eb25ac5d94f15f22b3ba3ab2ef60b603b97ae76f855072ea9e3a0)
- [QuickSwap Lend attack](https://quillaudits.medium.com/decoding-220k-read-only-reentrancy-exploit-quillaudits-30871d728ad5) – 23 October 2022 | [Victim contract](https://polygonscan.com/address/0x3dC7E6FF0fB79770FA6FB05d1ea4deACCe823943), [Exploit contract](https://polygonscan.com/address/0xEb4c67E5BE040068FA477a539341d6aeF081E4Eb), [Exploit transaction](https://polygonscan.com/tx/0xb8efe839da0c89daa763f39f30577dc21937ae351c6f99336a0017e63d387558)
- [n00dleSwap attack](https://twitter.com/BlockSecTeam/status/1584959295829180416) – 25 October 2022 | [Victim contract](https://etherscan.io/address/0x3561081260186E69369E6C32F280836554292E08), [Exploit contract](https://etherscan.io/address/0x9C5A2A6431523fBBC648fb83137A20A2C1789C56), [Exploit transaction](https://etherscan.io/tx/0x8037b3dc0bf9d5d396c10506824096afb8125ea96ada011d35faa89fa3893aea)
- [DFX Finance attack](https://blog.audit.haechi.io/dfx_finance_attack_overview) – 10 November 2022 | [Victim contract](https://etherscan.io/address/0x46161158b1947D9149E066d6d31AF1283b2d377C), [Exploit contract](https://etherscan.io/address/0x6cFa86a352339E766FF1cA119c8C40824f41F22D), [Exploit transaction](https://etherscan.io/tx/0x6bfd9e286e37061ed279e4f139fbc03c8bd707a2cdd15f7260549052cbba79b7)
- [Defrost Finance attack](https://twitter.com/PeckShieldAlert/status/1606276020276891650) – 23 December 2022 | [Victim contract](https://snowtrace.io/address/0xfF152e21C5A511c478ED23D1b89Bb9391bE6de96), [Exploit contract](https://snowtrace.io/address/0x792E8f3727cad6e00c58d478798F0907c4cEC340), [Exploit transaction](https://snowtrace.io/tx/0xc6fb8217e45870a93c25e2098f54f6e3b24674a3083c30664867de474bf0212d)
- [Jaypeggers attack](https://twitter.com/BlockSecTeam/status/1608372475225866240) – 29 December 2022 | [Victim contract](https://etherscan.io/address/0xf2919D1D80Aff2940274014bef534f7791906FF2), [Exploit contract](https://etherscan.io/address/0xed42Cb11b9D03c807ED1ba9c2eD1d3BA5Bf37340), [Exploit transaction](https://etherscan.io/tx/0xd4fafa1261f6e4f9c8543228a67caf9d02811e4ad3058a2714323964a8db61f6)
- [Midas Capital attack](https://twitter.com/AnciliaInc/status/1614705804468424704) – 15 January 2023 | [Victim contract](https://polygonscan.com/address/0xe150e792e0a18C9984a0630f051a607dEe3c265d), [Exploit contract](https://polygonscan.com/address/0x757E9F49aCfAB73C25b20D168603d54a66C723A1), [Exploit transaction](https://polygonscan.com/tx/0x0053490215baf541362fc78be0de98e3147f40223238d5b12512b3e26c0a2c2f)
- [2Pi Network attack](https://2pinetwork.medium.com/lessons-learned-from-exploit-incident-postmortem-70ad1a079b38) – 15 January 2023 | [Victim contract](https://optimistic.etherscan.io/address/0x6a5143b943578C18b9D28e7Acc123BBd7aac3282), [Exploit contract](https://optimistic.etherscan.io/address/0x0058a31Ac6F54175876c0C74C65Bd1B901A8a025), [Exploit transaction](https://optimistic.etherscan.io/tx/0x21449ae15ea6ccd737d9436426413388a6f4290cef93b8ed7f0eaa51f500d5df)
- [Abracadabra Money white hat attack](https://mirror.xyz/0x5744b051845B62D6f5B6Db095cc428bCbBBAc6F9/47LK6nUpMrVsYzfCYBTyZsc_7t5Sh5onxO8sSEotNMY) – 16 January 2023 | [Victim contract](https://arbiscan.io/address/0x1aDDD80E6039594eE970E5872D247bf0414C8903), [Exploit contract](https://arbiscan.io/address/0x3816A80F324B8f6F34cF76E5Ba9A256130d37f50), [Exploit transaction](https://arbiscan.io/tx/0x3f0aa143886f873a73ee9f1584c5f0d5043c5dff7e4f5c2ed34664dbe2fe9d25)
- [Orion Protocol attack](https://twitter.com/peckshield/status/1621337925228306433) – 2 February 2023 | [Victim contract](https://etherscan.io/address/0xb5599f568D3f3e6113B286d010d2BCa40A7745AA), [Exploit contract](https://etherscan.io/address/0x5061F7e6dfc1a867D945d0ec39Ea2A33f772380A), [Exploit transaction](https://etherscan.io/tx/0xa6f63fcb6bec8818864d96a5b1bb19e8bd85ee37b2cc916412e720988440b2aa)
- [dForce Network attack](https://twitter.com/BlockSecTeam/status/1623901011680333824)[^3] – 9 February 2023 | [Victim contract](https://arbiscan.io/address/0x2cE498b79C499c6BB64934042eBA487bD31F75ea), [Exploit contract](https://arbiscan.io/address/0xEe29b6AEE6E4783Db176946e4e8F1E5fDCD446A7), [Exploit transaction](https://arbiscan.io/tx/0x5db5c2400ab56db697b3cc9aa02a05deab658e1438ce2f8692ca009cc45171dd)
- [Dynamic attack](https://neptunemutual.com/blog/how-was-dynamic-finance-exploited) – 22 February 2023 | [Victim contract](https://bscscan.com/address/0xa7B5eabC3Ee82c585f5F4ccC26b81c3Bd62Ff3a9), [Exploit contract](https://bscscan.com/address/0xd360b416cE273AB2358419b1015aCf476a3b30d9), [Exploit transaction](https://bscscan.com/tx/0xc09678fec49c643a30fc8e4dec36d0507dae7e9123c270e1f073d335deab6cf0)
- [Sentiment attack](https://quillaudits.medium.com/decoding-sentiment-protocols-1-million-exploit-quillaudits-f36bee77d376) – 4 April 2023 | [Victim contract](https://arbiscan.io/address/0x0dDB1eA478F8eF0E22C7706D2903a41E94B1299B)[^4], [Exploit contract](https://arbiscan.io/address/0x9f626F5941FAfe0A5b839907d77fbBD5d0deA9D0), [Exploit transaction](https://arbiscan.io/tx/0xa9ff2b587e2741575daf893864710a5cbb44bb64ccdc487a100fa20741e0f74d)
- [Paribus attack](https://twitter.com/Phalcon_xyz/status/1645742620897955842) – 11 April 2023 | [Victim contract](https://arbiscan.io/address/0x375Ae76F0450293e50876D0e5bDC3022CAb23198)[^5], [Exploit contract](https://arbiscan.io/address/0xcd31E27F0A811de7139938b1972b475697f8c50b), [Exploit transaction](https://arbiscan.io/tx/0x0e29dcf4e9b211a811caf00fc8294024867bffe4ab2819cc1625d2e9d62390af)
- [MuratiAI attack](https://twitter.com/PeckShieldAlert/status/1666110220404428800) – 6 June 2023 | [Victim contract](https://bscscan.com/address/0x69C2fcAe7e30b429166BD616A322e32BeC036bCf), [Exploit contract](https://bscscan.com/address/0x5a4216E0990CaFEB540a253AD79b09ac2Acd3AD1), [Exploit transaction](https://bscscan.com/tx/0x62dbb9d5967d735ebf6fcfbbf3b7121194d4a7d61c85627388064cb8fe0ad65f)
- [Sturdy attack](https://twitter.com/BlockSecTeam/status/1668084629654638592) – 12 June 2023 | [Victim contract](https://etherscan.io/address/0xB1ebF8F77ae002d487e7Bde22c6180be0AF6a3d4), [Exploit contract](https://etherscan.io/address/0x0B09c86260C12294e3b967f0D523B4b2bcdFbeab), [Exploit transaction](https://etherscan.io/tx/0xeb87ebc0a18aca7d2a9ffcabf61aa69c9e8d3c6efade9e2303f8857717fb9eb7)
- [Arcadia Finance attack](https://arcadiafinance.medium.com/post-mortem-72e9d24a79b0)[^6] – 10 July 2023 | [Victim contract](https://optimistic.etherscan.io/address/0xD417c28aF20884088F600e724441a3baB38b22cc), [Exploit contract](https://optimistic.etherscan.io/address/0x01a4d9089C243CCaEbE40AA224ad0CaB573B83c6), [Exploit transaction](https://optimistic.etherscan.io/tx/0xca7c1a0fde444e1a68a8c2b8ae3fb76ec384d1f7ae9a50d26f8bfdd37c7a0afe)
- [Libertify attack](https://twitter.com/peckshield/status/1678688731908411393)[^7] – 11 July 2023 | [Victim contract](https://polygonscan.com/address/0x9c80a455ecaca7025A45F5fa3b85Fd6A462a447b), [Exploit contract](https://polygonscan.com/address/0xdFcDB5A86b167B3A418F3909D6f7A2f2873F2969), [Exploit transaction](https://polygonscan.com/tx/0x7320accea0ef1d7abca8100c82223533b624c82d3e8d445954731495d4388483)

_Edit:_ I tweeted about it [here](https://twitter.com/pcaversaccio/status/1549019584824590336) and will add further incidents if reported by the community.

_Update:_ Due to the overwhelming positive feedback I have received on Twitter, I decided to create my own repository [here](https://github.com/pcaversaccio/reentrancy-attacks) that tracks all of the reentrancy attacks. I will try my best to keep everything up to date.

[^1]: To prevent the article from constantly reloading, deactivate JavaScript in your browser.
[^2]: We list the attacker's address here for the sake of completeness, but technically the attack was executed with a Near-specific transaction type called ["Batch Transaction"](https://nomicon.io/RuntimeSpec/Transactions#batched-transaction) and not with a specific exploit contract.
[^3]: We list the victim contract, the exploit contract, and the exploit transaction on Arbitrum. However, the same exploit was carried out on Optimism with almost the same amount of loss: [Victim contract](https://optimistic.etherscan.io/address/0xDFeC2EA848Cf8fdA096503f8D9F37AFac6E0ECF2), [Exploit contract](https://optimistic.etherscan.io/address/0xEe29b6AEE6E4783Db176946e4e8F1E5fDCD446A7), [Exploit transaction](https://optimistic.etherscan.io/tx/0x6c19762186c9f32c81eb2a79420fc7ad4485aa916cab37ec278b216757bfba0d).
[^4]: The same exploit hit another victim with almost the same amount of loss: [Victim contract](https://arbiscan.io/address/0x4c8e1656E042A206EEf7e8fcff99BaC667E4623e).
[^5]: The same exploit hit two other victims with almost the same amount of loss: [Victim contract 2](https://arbiscan.io/address/0x367351F854506DA9B230CbB5E47332b8E58A1863), [Victim contract 3](https://arbiscan.io/address/0xD3e323a672F6568390f29f083259debB44C41f41).
[^6]: We list the victim contract, the exploit contract, and the exploit transaction on Optimism. However, the same exploit was carried out on Ethereum, albeit with a smaller loss amount: [Victim contract](https://etherscan.io/address/0x9aa024D3fd962701ED17F76c17CaB22d3dc9D92d), [Exploit contract](https://etherscan.io/address/0x56A35FAe9b0416360e1752A9abE78D89F51517CF), [Exploit transaction](https://etherscan.io/tx/0xefc4ac015069fdf9946997be0459db44c0491221159220be782454c32ec2d651).
[^7]: We list the victim contract, the exploit contract, and the exploit transaction on Polygon. However, the same exploit was carried out on Ethereum, albeit with a smaller loss amount: [Victim contract](https://etherscan.io/address/0x429032A407aed3D5fF84caf38EFF217eB4d322A9), [Exploit contract](https://etherscan.io/address/0xdFcDB5A86b167B3A418F3909D6f7A2f2873F2969), [Exploit transaction](https://etherscan.io/tx/0xcb0ad9da33ecabf75df0a24aabf8a4517e4a7c5b1b2f11fee3b6a1ad9299a282).

#### <img src="https://avatars.githubusercontent.com/u/33553806?v=4" width="50">[Genysys](https://github.com/Genysys) commented at [2022-07-18 13:35](https://github.com/ethereum/solidity/issues/12996#issuecomment-1187447819):

This is a great idea. Omni NFT was also an reentrancy attack and it would be great to have it here.

#### <img src="https://avatars.githubusercontent.com/u/87383155?u=92ab2406e2f45ff6a5191160c0e26976abe035b7&v=4" width="50">[0xalpharush](https://github.com/0xalpharush) commented at [2022-07-18 13:54](https://github.com/ethereum/solidity/issues/12996#issuecomment-1187492897):

Adding a mutex to functions that write after external calls would not address cases where separate functions read from stale values or overwrite the same storage value. 

Take an example from the SAILFISH paper where adding a mutex is insufficient: 
```
contract Test { 
	mapping(uint => uint) splits;
	mapping(uint => uint) deposits;
	mapping(uint => address payable) payee1;
	mapping(uint => address payable) payee2;
	uint lock;
	modifier nonReentrant() {
		lock = 1;
		_;
		lock = 0;
	}
	function updateSplit(uint id, uint split) public{
		require(split <= 100);
		splits[id] = split;
	}
	// [Step 1]: Set split of ’a’ (id = 0) to 100(%)
        // [Step 4]: Set split of ’a’ (id = 0) to 0(%)
	function splitFunds(uint id) public nonReentrant {
		address payable a = payee1[id];
		address payable b = payee2[id];
		uint depo = deposits[id];
		deposits[id] = 0;

                // [Step 2]: Transfer 100% fund to ’a’
                // [Step 3]: Reenter updateSplit
		a.call{value:(depo * splits[id] / 100)}("");
                 
                 // [Step 5]: Transfer 100% fund to ’b’
		b.transfer(depo * (100 - splits[id]) / 100);
 	}
}
```
Rather than strictly identifying instances that do not follow check-effects-interact, it would make sense to look for function calls that allow for control flow to be controlled externally (as opposed to explicitly indicated like an if-else statement). I think this is clear if one examines the output of `slither Test.sol --print slithir-ssa`:
```
Contract Test
        Function Test.updateSplit(uint256,uint256)
                Expression: require(bool)(split <= 100)
                IRs:
                        TMP_0(bool) = split_1 <= 100
                        TMP_1(None) = SOLIDITY_CALL require(bool)(TMP_0)
                Expression: splits[id] = split
                IRs:
                        REF_0(uint256) -> splits_0[id_1]
                        splits_1(mapping(uint256 => uint256)) := ϕ(['splits_0'])
                        REF_0 (->splits_1) := split_1(uint256)
        Function Test.splitFunds(uint256)
                IRs:
                        splits_2(mapping(uint256 => uint256)) := ϕ(['splits_4', 'splits_1', 'splits_0'])
                        deposits_1(mapping(uint256 => uint256)) := ϕ(['deposits_0', 'deposits_3'])
                        payee1_1(mapping(uint256 => address)) := ϕ(['payee1_2', 'payee1_0'])
                        payee2_1(mapping(uint256 => address)) := ϕ(['payee2_0', 'payee2_2'])
                Expression: a = payee1[id]
                IRs:
                        REF_1(address) -> payee1_2[id_1]
                        a_1(address) := REF_1(address)
                Expression: b = payee2[id]
                IRs:
                        REF_2(address) -> payee2_2[id_1]
                        b_1(address) := REF_2(address)
                Expression: depo = deposits[id]
                IRs:
                        REF_3(uint256) -> deposits_2[id_1]
                        depo_1(uint256) := REF_3(uint256)
                Expression: deposits[id] = 0
                IRs:
                        REF_4(uint256) -> deposits_2[id_1]
                        deposits_3(mapping(uint256 => uint256)) := ϕ(['deposits_2'])
                        REF_4 (->deposits_3) := 0(uint256)
                Expression: a.call{value: (depo * splits[id] / 100)}()
                IRs:
                        REF_6(uint256) -> splits_3[id_1]
                        TMP_2(uint256) = depo_1 (c)* REF_6
                        TMP_3(uint256) = TMP_2 (c)/ 100
                        TUPLE_0(bool,bytes) = LOW_LEVEL_CALL, dest:a_1, function:call, arguments:[''] value:TMP_3 
                        splits_4(mapping(uint256 => uint256)) := ϕ(['splits_3', 'splits_1', 'splits_4'])
                Expression: b.transfer(depo * (100 - splits[id]) / 100)
                IRs:
                        REF_8(uint256) -> splits_4[id_1]
                        TMP_4(uint256) = 100 (c)- REF_8
                        TMP_5(uint256) = depo_1 (c)* TMP_4
                        TMP_6(uint256) = TMP_5 (c)/ 100
                        Transfer dest:b_1 value:TMP_6
                Expression: nonReentrant()
                IRs:
                        MODIFIER_CALL, Test.nonReentrant()()
```
Upon examination, after `a.call` the mapping, `splits`, has a phi value, `splits_1`, that indicates the value can be updated during an external call in `updateSplit` and used to withdraw more funds than intended. This is essentially a source of "undefined behavior" that results from a developer not being explicit enough about the anticipated control flow. For background, Slither's SSA form creates phi variables after external calls (non STATICCALL) because it is a point where control flow merges. 

If we treat reentrancy as an undefined behavior problem, I think we could find a happy medium that is not cumbersome for developers yet eliminates undefined behavior. This would encourage specification and hopefully reduce false positives/ fighting the compiler.

In order to introduce these sort of enhancements, I think it would make sense to consider the points raised in this [issue](https://github.com/ethereum/solidity/issues/13247#issuecomment-1175297584) and move towards a modular compiler design. People could opt in to passes that have more advanced analysis than the Solidity compiler and harden their code as they see fit (this is a common practice for other compiled languages). In addition, pruning infeasible paths would likely be slow and only required to run on "release" builds.


P.S. I also like the use of TLOAD for reentrancy protection and think it would give developers less of a reason to circumvent compiler-generated protections, e.g. turning off reentrancy mitigations to reduce SLOADs.

#### <img src="https://avatars.githubusercontent.com/u/811305?u=b2a7f87d77c4fd8a388b45691c92912df24ea6e1&v=4" width="50">[lukehutch](https://github.com/lukehutch) commented at [2022-07-18 17:18](https://github.com/ethereum/solidity/issues/12996#issuecomment-1187821841):

> Let me try to share a common, chronological list of reentrancy attacks including their (mostly) detailed analyses:

@pcaversaccio an awesome list -- thanks for compiling this!

> Adding a mutex to functions that write after external calls would not address cases where separate functions read from stale values or overwrite the same storage value.

@0xalpharush Correct, it's insufficient to prevent state changes if a parent frame in the call stack is a call to an external contract. You have to prevent state changes if a call was made to an external contract _at any previous point in the same transaction_. This is why I referred to EIP-1153, since it will provide a supported mechanism for binding state to the life of a transaction.

However, perhaps this can be approximated by calculating

```solidity
bytes32 transactionId = keccak256(abi.encode(block.chainid, block.number));
```

then modifiers could be created for functions that call external contracts and functions that update internal state as follows:

```solidity
contract X {
    bytes32 private extContractLastCalled_transactionId;

    modifier extContractCaller() {
        extContractLastCalled_transactionId = keccak256(abi.encode(block.chainid, block.number));
        _;
    }

    modifier updateState() {
        require (keccak256(abi.encode(block.chainid, block.number)) != extContractLastCalled_transactionId,
                    "Can't update state after calling external contract in the same transaction");
        _;
    }
}
```

I think this would work, but it's not ideal, because

1. It is coarse-grained (applying at the level of function definitions, rather than per-line). This means the programmer has to be careful to segregate functions into external caller functions and state updater functions. If function modification is done automatically by the compiler using the above pattern, it will have to fail if a function both updates state and calls an external contract.
2. It fails at runtime, not compiletime (I'm pretty sure 99% of relevant cases could be caught statically, through control flow analysis -- basically anything that is computable, which excludes cases where e.g. you call a data-derived function selector or something).

#### <img src="https://avatars.githubusercontent.com/u/33553806?v=4" width="50">[Genysys](https://github.com/Genysys) commented at [2022-07-18 17:48](https://github.com/ethereum/solidity/issues/12996#issuecomment-1187924559):

> However, perhaps this can be approximated by calculating
> 
> ```solidity
> bytes32 transactionId = keccak256(abi.encode(block.chainid, block.number));
> ```
> 

Would replacing the mutex modifier with this and having the compiler automatically include it in every call be a reasonable compromise?

#### <img src="https://avatars.githubusercontent.com/u/811305?u=b2a7f87d77c4fd8a388b45691c92912df24ea6e1&v=4" width="50">[lukehutch](https://github.com/lukehutch) commented at [2022-07-19 07:46](https://github.com/ethereum/solidity/issues/12996#issuecomment-1188714924):

Actually I think `transactionId` may need to also hash `tx.origin`, i.e.

```solidity
bytes32 transactionId = keccak256(abi.encode(block.chainid, block.number, tx.origin));
```

Although this still doesn't handle the case of a single EOA submitting multiple transactions to be mined in a single block.

Is there any other way to reliably differentiate different transactions?

#### <img src="https://avatars.githubusercontent.com/u/25297591?u=3251a9019e72f66e32ba31d57729796ad505c530&v=4" width="50">[pcaversaccio](https://github.com/pcaversaccio) commented at [2022-07-25 14:23](https://github.com/ethereum/solidity/issues/12996#issuecomment-1194118127):

Just as a quick reference for comparison, Vyper uses a simple [`@nonreentrant(<key>)`](https://vyper.readthedocs.io/en/latest/control-structures.html#re-entrancy-locks) decorator (which equals a modifier in Solidity) to prevent reentrancies. I haven't investigated in detail the decorator's behaviour but from the first sight, it would still allow for cross-contract reentrancies as well as for the above example shared by @0xalpharush in case `updateSplit` would not be protected by such a decorator.

The main point is the following:
> Nonreentrancy locks work by setting a specially allocated storage slot to a <locked> value on function entrance, and setting it to an <unlocked> value on function exit. On function entrance, if the storage slot is detected to be the <locked> value, execution reverts.

#### <img src="https://avatars.githubusercontent.com/u/25297591?u=3251a9019e72f66e32ba31d57729796ad505c530&v=4" width="50">[pcaversaccio](https://github.com/pcaversaccio) commented at [2022-07-29 08:53](https://github.com/ethereum/solidity/issues/12996#issuecomment-1199036226):

Linking this [EIP initiative](https://github.com/SergioDemianLerner/EIPs-Semaphore/blob/36c0f795deceee205023da4968549a7a8e86d511/EIPS/eip-semaphore.md) by @SergioDemianLerner since it can be relevant to this discussion. The proposal is to implement (through a hard fork) a reentrancy guard as a precompile. I don't think we should solve this issue via a hard fork. It's not an EVM problem but a compiler problem. Even if we had such a pre-compile, the discussed issue would still exist by _default_.

#### <img src="https://avatars.githubusercontent.com/u/811305?u=b2a7f87d77c4fd8a388b45691c92912df24ea6e1&v=4" width="50">[lukehutch](https://github.com/lukehutch) commented at [2022-07-29 14:11](https://github.com/ethereum/solidity/issues/12996#issuecomment-1199352257):

@pcaversaccio right, a hard fork would solve the problem in the wrong way. Reentrance can and should be statically determined. Slither already does this (although I don't know what degree of complexity it handles).

#### <img src="https://avatars.githubusercontent.com/u/5469459?u=e82c610193c2ff51a80bff8f61cda20dda6abecb&v=4" width="50">[gpersoon](https://github.com/gpersoon) commented at [2022-08-01 13:07](https://github.com/ethereum/solidity/issues/12996#issuecomment-1201178506):

With ERC777 it can be the other way around see: https://twitter.com/transmissions11/status/1496944873760428058

#### <img src="https://avatars.githubusercontent.com/u/811305?u=b2a7f87d77c4fd8a388b45691c92912df24ea6e1&v=4" width="50">[lukehutch](https://github.com/lukehutch) commented at [2022-08-01 19:28](https://github.com/ethereum/solidity/issues/12996#issuecomment-1201622750):

> With ERC777 it can be the other way around see: https://twitter.com/transmissions11/status/1496944873760428058

Good point, and correct, I pointed that out here: https://github.com/OpenZeppelin/openzeppelin-contracts/issues/2620#issuecomment-1156118047

The ERC777 standard is insecure by default, and needs to be deprecated. But presumably there should be a compiler directive in case anyone really wanted to turn off Checks-Effects-Interactions order checking for a given function.

#### <img src="https://avatars.githubusercontent.com/u/1752347?u=f52233009451d6489b81666f87a8614416e0e687&v=4" width="50">[SergioDemianLerner](https://github.com/SergioDemianLerner) commented at [2022-08-02 23:05](https://github.com/ethereum/solidity/issues/12996#issuecomment-1203296364):

My [EIP-5283](https://github.com/ethereum/EIPs/blob/0ac341a39e3927b0cb51aa4d2e96fc19475f1bc8/EIPS/eip-5283.md) represents the simplest hard-fork that provides the mutex functionality that is future-proof for EVM parallel tx execution with fine-grained parallelization. The sooner we introduce such a feature, the higher the number of deployed contracts will be parallelizable.
I would also prefer the transient opcodes TLOAD and TSTORE to be used, but adding opcodes is not as easy, since it impacts a lot of tooling.

#### <img src="https://avatars.githubusercontent.com/u/25297591?u=3251a9019e72f66e32ba31d57729796ad505c530&v=4" width="50">[pcaversaccio](https://github.com/pcaversaccio) commented at [2022-10-13 18:11](https://github.com/ethereum/solidity/issues/12996#issuecomment-1277993463):

I would like to highlight as part of this discussion a recent reentrancy issue on `view` functions. Some documentation on this:
- https://chainsecurity.com/heartbreaks-curve-lp-oracles/
- https://chainsecurity.com/curve-lp-oracle-manipulation-post-mortem/
- https://forum.makerdao.com/t/curve-lp-token-oracle-manipulation-vulnerability-emergency-response-postmortem/18011
- https://forum.makerdao.com/t/curve-lp-token-oracle-manipulation-vulnerability-technical-postmortem/18009
- https://www.euler.finance/blog/read-only-re-entrancy-guards

A read-only reentrancy reenters `view` functions which, in contrast to state-altering functions, lack reentrancy guards — enabling the read-only reentrancy. While the reentered contract cannot be affected by its `view` function, others reading the contract's state can. I'm not yet sure how much of such an attack can be prevented at the compiler level since disallowing reentering `view` functions by default is not an appropriate solution IMHO. Any opinions?

#### <img src="https://avatars.githubusercontent.com/u/811305?u=b2a7f87d77c4fd8a388b45691c92912df24ea6e1&v=4" width="50">[lukehutch](https://github.com/lukehutch) commented at [2022-10-14 00:31](https://github.com/ethereum/solidity/issues/12996#issuecomment-1278321034):

> A read-only reentrancy reenters `view` functions which, in contrast to state-altering functions, lack reentrancy guards — enabling the read-only reentrancy. While the reentered contract cannot be affected by its `view` function, others reading the contract's state can. I'm not yet sure how much of such an attack can be prevented at the compiler level since disallowing reentering `view` functions by default is not an appropriate solution IMHO. Any opinions?

Core to this problem is the issue that contract storage reads and writes can be interleaved across inter-contract calls. It seems to me that there would be two ways to prevent this issue, both of which would require EVM changes:

(1) Deny read access to the storage of a contract after the first attempt to write to the contract's storage, until the end of the transaction. This could be switched on with a pragma, for extra security, but it would probably feel restrictive.

(2) Add opcodes to the EVM to read the *consensus-committed* values from storage (i.e. use copy-on-write to keep a copy of the "old" values and the "new" values of the storage of a contract, and have opcodes that only read "old" values. Then, when a transaction is committed, the "new" values are treated as the "old" values for the next transaction). This would require changes to EVM-targeting languages, but it would be possible to treat view functions as quasi-pure if their return value depends only upon old values, as it cannot be affected by any write operation, at least until the transaction is committed.

#### <img src="https://avatars.githubusercontent.com/u/41608339?u=3faaeb55c5906fc81aac93ba5b5ae1b10b0eeae9&v=4" width="50">[tangpin213](https://github.com/tangpin213) commented at [2022-11-27 14:32](https://github.com/ethereum/solidity/issues/12996#issuecomment-1328259457):

I don't think iron finance was ever exploited by reentrance attack. The mentioned tx showed normal interaction. Moreover, neither IRON and TITAN token can be used the reentrance attack, even though the pool contract could be reentraned given certian type of pool token.

#### <img src="https://avatars.githubusercontent.com/u/25297591?u=3251a9019e72f66e32ba31d57729796ad505c530&v=4" width="50">[pcaversaccio](https://github.com/pcaversaccio) commented at [2022-11-27 16:11](https://github.com/ethereum/solidity/issues/12996#issuecomment-1328278814):

@tangpin213 the Iron Finance attack is a little special, you can read about it [here](https://thedefiant.io/not-just-a-bank-run-new-evidence-shows-iron-finance-crashed-due-to-code-exploit). It's debatable whether to list it as a pure reentrancy attack or not since it requires a malicious LP contract - I decided to list it due to the sake of completeness. 

**TL; DR:** The `MasterChef` contracts all have an `emergencyWithdraw` function that can be used for a cross-function reentrancy attack. If in any case a malicious contract is added to the pool it will be able to steal LP tokens from the pool.

Also, I would like to highlight that even though a token contract is not subject to reentrancy, a reentrancy attack can still be executed, e.g. across multiple systems (cross-contract reentrancy attack).

#### <img src="https://avatars.githubusercontent.com/u/41608339?u=3faaeb55c5906fc81aac93ba5b5ae1b10b0eeae9&v=4" width="50">[tangpin213](https://github.com/tangpin213) commented at [2022-11-27 16:16](https://github.com/ethereum/solidity/issues/12996#issuecomment-1328280048):

@

> pcaversaccio

Thank you for reply. I agree with your thoughts!

#### <img src="https://avatars.githubusercontent.com/u/88808051?u=d5401ae66a7575536a09b6b13f6796b794b5f02f&v=4" width="50">[SaveSnowflake](https://github.com/SaveSnowflake) commented at [2023-03-03 08:31](https://github.com/ethereum/solidity/issues/12996#issuecomment-1453158150):

Thank you for doing this post

#### <img src="https://avatars.githubusercontent.com/u/25297591?u=3251a9019e72f66e32ba31d57729796ad505c530&v=4" width="50">[pcaversaccio](https://github.com/pcaversaccio) commented at [2023-05-01 19:13](https://github.com/ethereum/solidity/issues/12996#issuecomment-1530096708):

Since [EIP-1153](https://eips.ethereum.org/EIPS/eip-1153) is confirmed to be included in the upcoming Cancun-Deneb upgrade, we now have transient opcodes at hand that can 'easily' be used to disable reentrancy by default. I really think this is very important and should be included in the `0.9.0` solc roadmap. For the sake of transparency, I cross-reference the current Vyper discussion here as well: https://github.com/vyperlang/vyper/issues/3380.

#### <img src="https://avatars.githubusercontent.com/u/25297591?u=3251a9019e72f66e32ba31d57729796ad505c530&v=4" width="50">[pcaversaccio](https://github.com/pcaversaccio) commented at [2023-05-03 15:28](https://github.com/ethereum/solidity/issues/12996#issuecomment-1533249792):

For the sake of documentation, linking a very interesting write-up by @0xalpharush on the discussed matter: https://gist.github.com/0xalpharush/15d903ec43334b081caece21a0bd7a20. Also, @jtriley-eth provided interesting thoughts for reflection.

#### <img src="https://avatars.githubusercontent.com/in/15368?v=4" width="50">[github-actions](https://github.com/apps/github-actions) commented at [2023-10-10 12:04](https://github.com/ethereum/solidity/issues/12996#issuecomment-1755236136):

This issue has been marked as stale due to inactivity for the last 90 days.
It will be automatically closed in 7 days.

#### <img src="https://avatars.githubusercontent.com/u/25297591?u=3251a9019e72f66e32ba31d57729796ad505c530&v=4" width="50">[pcaversaccio](https://github.com/pcaversaccio) commented at [2023-10-10 12:06](https://github.com/ethereum/solidity/issues/12996#issuecomment-1755241030):

Don't close this issue as this is still _very_ important.

#### <img src="https://avatars.githubusercontent.com/in/15368?v=4" width="50">[github-actions](https://github.com/apps/github-actions) commented at [2024-01-10 12:04](https://github.com/ethereum/solidity/issues/12996#issuecomment-1884723158):

This issue has been marked as stale due to inactivity for the last 90 days.
It will be automatically closed in 7 days.

#### <img src="https://avatars.githubusercontent.com/u/25297591?u=3251a9019e72f66e32ba31d57729796ad505c530&v=4" width="50">[pcaversaccio](https://github.com/pcaversaccio) commented at [2024-01-10 12:07](https://github.com/ethereum/solidity/issues/12996#issuecomment-1884727002):

Don't close this issue as this is still very important.

#### <img src="https://avatars.githubusercontent.com/in/15368?v=4" width="50">[github-actions](https://github.com/apps/github-actions) commented at [2024-04-10 12:04](https://github.com/ethereum/solidity/issues/12996#issuecomment-2047368530):

This issue has been marked as stale due to inactivity for the last 90 days.
It will be automatically closed in 7 days.

#### <img src="https://avatars.githubusercontent.com/u/25297591?u=3251a9019e72f66e32ba31d57729796ad505c530&v=4" width="50">[pcaversaccio](https://github.com/pcaversaccio) commented at [2024-04-10 12:08](https://github.com/ethereum/solidity/issues/12996#issuecomment-2047376633):

Don't close this issue as this is still very important.

#### <img src="https://avatars.githubusercontent.com/in/15368?v=4" width="50">[github-actions](https://github.com/apps/github-actions) commented at [2024-07-10 12:05](https://github.com/ethereum/solidity/issues/12996#issuecomment-2220338356):

This issue has been marked as stale due to inactivity for the last 90 days.
It will be automatically closed in 7 days.

#### <img src="https://avatars.githubusercontent.com/u/25297591?u=3251a9019e72f66e32ba31d57729796ad505c530&v=4" width="50">[pcaversaccio](https://github.com/pcaversaccio) commented at [2024-07-10 12:08](https://github.com/ethereum/solidity/issues/12996#issuecomment-2220344693):

Don't close this issue as this is still very important. @cameel this is a super important feature and it seems like it's not getting the attention it should internally in the Solidity team IMHO over the last 2 years.

#### <img src="https://avatars.githubusercontent.com/u/32997409?u=b4f328ebdfeb0517e767cf91f267149f15bc3d7c&v=4" width="50">[mehtavishwa30](https://github.com/mehtavishwa30) commented at [2024-07-10 16:54](https://github.com/ethereum/solidity/issues/12996#issuecomment-2221017041):

Hey @pcaversaccio!

Appreciate you proposing these changes and keeping the issue alive. From our internal discussions, we understand the desire to have such functionality within the Solidity compiler. However, given our current priorities the team will continue focusing on making via-IR viable and specifying the next iteration of Solidity for which we will keep this proposal in mind. At the moment, we won't be introducing such functionality which serves as grounds for closing the issue.

In the meantime, you can make use of various static analysis tools available that can perform the desired safety checks outside the compiler. Some of them are even mentioned in the thread above.

#### <img src="https://avatars.githubusercontent.com/u/1758597?u=e6b97b4c178c42dc306fbd59a6b76b7238a2430d&v=4" width="50">[itinance](https://github.com/itinance) commented at [2024-07-10 23:26](https://github.com/ethereum/solidity/issues/12996#issuecomment-2221697329):

Sad to read that comment @mehtavishwa30. This is really a bad decision and will lead to even more millions of billions of frozen and/or locked and/or robbed funds.

#### <img src="https://avatars.githubusercontent.com/u/135433666?u=b408b9bdf4549052acc7a0d8993238b702f121c3&v=4" width="50">[tormentr](https://github.com/tormentr) commented at [2024-07-11 14:21](https://github.com/ethereum/solidity/issues/12996#issuecomment-2223070295):

> Hey @pcaversaccio!
> 
> Appreciate you proposing these changes and keeping the issue alive. From our internal discussions, we understand the desire to have such functionality within the Solidity compiler. However, given our current priorities the team will continue focusing on making via-IR viable and specifying the next iteration of Solidity for which we will keep this proposal in mind. At the moment, we won't be introducing such functionality which serves as grounds for closing the issue.
> 
> In the meantime, you can make use of various static analysis tools available that can perform the desired safety checks outside the compiler. Some of them are even mentioned in the thread above.

![](https://media1.tenor.com/m/qJ26nyWwVaoAAAAC/kim-jong-un-serious.gif)

#### <img src="https://avatars.githubusercontent.com/u/63709472?u=b1426400293dd59fe84ccbc0dbd4519fe8c4834e&v=4" width="50">[indeqs](https://github.com/indeqs) commented at [2024-07-12 13:38](https://github.com/ethereum/solidity/issues/12996#issuecomment-2225611284):

Just came from @pcaversaccio tweet as seen [here](https://x.com/pcaversaccio/status/1811088827789774969?t=lnelG_9tymlrJXoOLpeyEQ&s=19) and this really does need the attention that it deserves. It's been 2 years ffs.

The North Korean guys are probably laughing at us right now!

#### <img src="https://avatars.githubusercontent.com/u/1347491?v=4" width="50">[ekpyron](https://github.com/ekpyron) commented at [2024-07-15 13:53](https://github.com/ethereum/solidity/issues/12996#issuecomment-2228562881):

Just to be clear here: this issue is about performing source level analysis in order to disallow state-changing effects after an external call unless a specific syntactic marker is used and *not* about mitigating reentrancy-attacks in general and (while the discussion in the issue has over time shifted towards it as a different solution to the underlying problem) also *not* about builtin reentrancy guards by default.
That's what @mehtavishwa30's comment was targetting and that's what we're currently not planning to implement given the possibility to use cheap reentrancy guards based on transient storage. And that's why we're closing this issue - the case for reentrancy guards per default in 0.9.0 can be made in a separate appropriately titled issue.


-------------------------------------------------------------------------------



[Export of Github issue for [ethereum/solidity](https://github.com/ethereum/solidity). Generated on 2024.12.15 at 06:45:24.]
