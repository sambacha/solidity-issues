# [\#14444 Issue](https://github.com/ethereum/solidity/issues/14444) `closed`: Inconsistent gas usage for conversion of calldata to memory in external call and internal call.
**Labels**: `bug :bug:`


#### <img src="https://avatars.githubusercontent.com/u/8362565?u=c59e95752146dd37ad7d06d0558283ed877eb546&v=4" width="50">[charlesxsh](https://github.com/charlesxsh) opened issue at [2023-07-24 06:50](https://github.com/ethereum/solidity/issues/14444):

## Description

Inconsistent gas usage for conversion of calldata to memory in external call and internal call. This is observed after 0.8.0. In 0.7.6, their gas usages are the consistent.

## Environment

- Compiler version: 0.8.17
- Target EVM version (as per compiler settings): any
- Framework/IDE (e.g. Truffle or Remix): Remix
- EVM execution environment / backend / blockchain client: any
- Operating system: any

## Steps to Reproduce

```solidity
// SPDX-License-Identifier: GPL-3.0
pragma solidity >=0.7.0 <0.9.0;


contract Dummy {
    function iacceptmem(uint256[] memory amounts) internal {
    }
   
    function test1(uint256[] memory amounts) external {
        iacceptmem(amounts);
    }

    function test2(uint256[] calldata amounts) external {
        iacceptmem(amounts);
    }

}


contract Tester {
    Dummy d = new Dummy();

    function call_test1() external {
        uint256[] memory data = new uint256[](1000);
        d.test1(data);
    }

    function call_test2() external {
        uint256[] memory data = new uint256[](1000);
        d.test2(data);
    }
}
```

If you deploy Tester and call `call_test1` and `call_test2`, you will find that execution cost of `call_test2` is 295126, but `call_test1` is 517391. From yul, we can see they both have the conversion from calldata to memory once. But what is the difference is `call_test2` is converting before `iacceptmem` call, `call_test1` is converting at before executing the `test1`.



#### <img src="https://avatars.githubusercontent.com/u/457348?u=e02c93e6d98c1154952140a8d5af50d9d5ca59c9&v=4" width="50">[r0qs](https://github.com/r0qs) commented at [2023-07-25 10:47](https://github.com/ethereum/solidity/issues/14444#issuecomment-1649599171):

Hi @charlesxsh,

thanks for reaching out, however this is not an issue. A possible reason of the gas difference can be the switch to [ABIEncoderV2](https://docs.soliditylang.org/en/latest/080-breaking-changes.html#silent-changes-of-the-semantics) which has more validation on calldata arguments, but there is no reason to believe those two functions should have equal cost. The fact that they had in previous releases is just coincidence.

I'm cross-posting a discussion that we have with @ekpyron about your example that may help to understand what is happening:
```
The first function copies from calldata to memory before entering the function, passing around merely 
a memory reference.
The second one keeps things in calldata at first (while performing some validation on it) and then does 
a full copy to memory later on the `iacceptmem` call.
I don't see how anything else could be happening there and why that would have same cost.
```

#### <img src="https://avatars.githubusercontent.com/u/8362565?u=c59e95752146dd37ad7d06d0558283ed877eb546&v=4" width="50">[charlesxsh](https://github.com/charlesxsh) commented at [2023-07-25 15:10](https://github.com/ethereum/solidity/issues/14444#issuecomment-1650028838):

Hi there, thanks for replying! However, I am not sure I fully understand the point here. I believe they should have similar gas consumption because they both convert from `calldata` to `memory` once. The only difference is the happening order. From yul file, it also proves that the most heavy function `abi_decode_available_length_t_array$_t_uint256_$dyn_memory_ptr` is called:
1. For `Dummy.test1 `, it is called in the wrapper before actually calling `Dummy.test1`
2. For `Dummy.test2`, it is called before calling `iacceptmem`

In Remix IDE, the gas consumption for `Tester.call_test1` and `Tester.call_test2` is **552455** and **316317**. Not sure I understand correctly, it seems like you both think the second one should consume more. 
From yul file, they indeed have some small differences on CALLDATALOAD and other opcode, but that cannot explain the huge gas difference here.
Would you elaborate more about why they have such huge gas consumption?

@r0qs @ekpyron

#### <img src="https://avatars.githubusercontent.com/u/8362565?u=c59e95752146dd37ad7d06d0558283ed877eb546&v=4" width="50">[charlesxsh](https://github.com/charlesxsh) commented at [2023-07-25 15:14](https://github.com/ethereum/solidity/issues/14444#issuecomment-1650036715):

Attach the yul file here for convenience.
```
IR:

/// @use-src 0:"test.sol"
object "Dummy_31" {
    code {
        /// @src 0:34:309  "contract Dummy {..."
        mstore(64, memoryguard(128))
        if callvalue() { revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb() }

        constructor_Dummy_31()

        let _1 := allocate_unbounded()
        codecopy(_1, dataoffset("Dummy_31_deployed"), datasize("Dummy_31_deployed"))

        return(_1, datasize("Dummy_31_deployed"))

        function allocate_unbounded() -> memPtr {
            memPtr := mload(64)
        }

        function revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb() {
            revert(0, 0)
        }

        /// @src 0:34:309  "contract Dummy {..."
        function constructor_Dummy_31() {

            /// @src 0:34:309  "contract Dummy {..."

        }
        /// @src 0:34:309  "contract Dummy {..."

    }
    /// @use-src 0:"test.sol"
    object "Dummy_31_deployed" {
        code {
            /// @src 0:34:309  "contract Dummy {..."
            mstore(64, memoryguard(128))

            if iszero(lt(calldatasize(), 4))
            {
                let selector := shift_right_224_unsigned(calldataload(0))
                switch selector

                case 0x6a3273b7
                {
                    // test1(uint256[])

                    external_fun_test1_19()
                }

                case 0x6f1f05ed
                {
                    // test2(uint256[])

                    external_fun_test2_30()
                }

                default {}
            }

            revert_error_42b3090547df1d2001c96683413b8cf91c1b902ef5e3cb8d9f6f304cf7446f74()

            function shift_right_224_unsigned(value) -> newValue {
                newValue :=

                shr(224, value)

            }

            function allocate_unbounded() -> memPtr {
                memPtr := mload(64)
            }

            function revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb() {
                revert(0, 0)
            }

            function revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b() {
                revert(0, 0)
            }

            function revert_error_c1322bf8034eace5e0b5c7295db60986aa89aae5e0ea0873e4689e076861a5db() {
                revert(0, 0)
            }

            function revert_error_1b9f4a0a5773e33b91aa01db23bf8c55fce1411167c872835e7fa00a4f17d46d() {
                revert(0, 0)
            }

            function round_up_to_mul_of_32(value) -> result {
                result := and(add(value, 31), not(31))
            }

            function panic_error_0x41() {
                mstore(0, 35408467139433450592217433187231851964531694900788300625387963629091585785856)
                mstore(4, 0x41)
                revert(0, 0x24)
            }

            function finalize_allocation(memPtr, size) {
                let newFreePtr := add(memPtr, round_up_to_mul_of_32(size))
                // protect against overflow
                if or(gt(newFreePtr, 0xffffffffffffffff), lt(newFreePtr, memPtr)) { panic_error_0x41() }
                mstore(64, newFreePtr)
            }

            function allocate_memory(size) -> memPtr {
                memPtr := allocate_unbounded()
                finalize_allocation(memPtr, size)
            }

            function array_allocation_size_t_array$_t_uint256_$dyn_memory_ptr(length) -> size {
                // Make sure we can allocate memory without overflow
                if gt(length, 0xffffffffffffffff) { panic_error_0x41() }

                size := mul(length, 0x20)

                // add length slot
                size := add(size, 0x20)

            }

            function revert_error_81385d8c0b31fffe14be1da910c8bd3a80be4cfa248e04f42ec0faea3132a8ef() {
                revert(0, 0)
            }

            function cleanup_t_uint256(value) -> cleaned {
                cleaned := value
            }

            function validator_revert_t_uint256(value) {
                if iszero(eq(value, cleanup_t_uint256(value))) { revert(0, 0) }
            }

            function abi_decode_t_uint256(offset, end) -> value {
                value := calldataload(offset)
                validator_revert_t_uint256(value)
            }

            // uint256[]
            function abi_decode_available_length_t_array$_t_uint256_$dyn_memory_ptr(offset, length, end) -> array {
                array := allocate_memory(array_allocation_size_t_array$_t_uint256_$dyn_memory_ptr(length))
                let dst := array

                mstore(array, length)
                dst := add(array, 0x20)

                let srcEnd := add(offset, mul(length, 0x20))
                if gt(srcEnd, end) {
                    revert_error_81385d8c0b31fffe14be1da910c8bd3a80be4cfa248e04f42ec0faea3132a8ef()
                }
                for { let src := offset } lt(src, srcEnd) { src := add(src, 0x20) }
                {

                    let elementPos := src

                    mstore(dst, abi_decode_t_uint256(elementPos, end))
                    dst := add(dst, 0x20)
                }
            }

            // uint256[]
            function abi_decode_t_array$_t_uint256_$dyn_memory_ptr(offset, end) -> array {
                if iszero(slt(add(offset, 0x1f), end)) { revert_error_1b9f4a0a5773e33b91aa01db23bf8c55fce1411167c872835e7fa00a4f17d46d() }
                let length := calldataload(offset)
                array := abi_decode_available_length_t_array$_t_uint256_$dyn_memory_ptr(add(offset, 0x20), length, end)
            }

            function abi_decode_tuple_t_array$_t_uint256_$dyn_memory_ptr(headStart, dataEnd) -> value0 {
                if slt(sub(dataEnd, headStart), 32) { revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b() }

                {

                    let offset := calldataload(add(headStart, 0))
                    if gt(offset, 0xffffffffffffffff) { revert_error_c1322bf8034eace5e0b5c7295db60986aa89aae5e0ea0873e4689e076861a5db() }

                    value0 := abi_decode_t_array$_t_uint256_$dyn_memory_ptr(add(headStart, offset), dataEnd)
                }

            }

            function abi_encode_tuple__to__fromStack(headStart ) -> tail {
                tail := add(headStart, 0)

            }

            function external_fun_test1_19() {

                if callvalue() { revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb() }
                let param_0 :=  abi_decode_tuple_t_array$_t_uint256_$dyn_memory_ptr(4, calldatasize())
                fun_test1_19(param_0)
                let memPos := allocate_unbounded()
                let memEnd := abi_encode_tuple__to__fromStack(memPos  )
                return(memPos, sub(memEnd, memPos))

            }

            function revert_error_15abf5612cd996bc235ba1e55a4a30ac60e6bb601ff7ba4ad3f179b6be8d0490() {
                revert(0, 0)
            }

            // uint256[]
            function abi_decode_t_array$_t_uint256_$dyn_calldata_ptr(offset, end) -> arrayPos, length {
                if iszero(slt(add(offset, 0x1f), end)) { revert_error_1b9f4a0a5773e33b91aa01db23bf8c55fce1411167c872835e7fa00a4f17d46d() }
                length := calldataload(offset)
                if gt(length, 0xffffffffffffffff) { revert_error_15abf5612cd996bc235ba1e55a4a30ac60e6bb601ff7ba4ad3f179b6be8d0490() }
                arrayPos := add(offset, 0x20)
                if gt(add(arrayPos, mul(length, 0x20)), end) { revert_error_81385d8c0b31fffe14be1da910c8bd3a80be4cfa248e04f42ec0faea3132a8ef() }
            }

            function abi_decode_tuple_t_array$_t_uint256_$dyn_calldata_ptr(headStart, dataEnd) -> value0, value1 {
                if slt(sub(dataEnd, headStart), 32) { revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b() }

                {

                    let offset := calldataload(add(headStart, 0))
                    if gt(offset, 0xffffffffffffffff) { revert_error_c1322bf8034eace5e0b5c7295db60986aa89aae5e0ea0873e4689e076861a5db() }

                    value0, value1 := abi_decode_t_array$_t_uint256_$dyn_calldata_ptr(add(headStart, offset), dataEnd)
                }

            }

            function external_fun_test2_30() {

                if callvalue() { revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb() }
                let param_0, param_1 :=  abi_decode_tuple_t_array$_t_uint256_$dyn_calldata_ptr(4, calldatasize())
                fun_test2_30(param_0, param_1)
                let memPos := allocate_unbounded()
                let memEnd := abi_encode_tuple__to__fromStack(memPos  )
                return(memPos, sub(memEnd, memPos))

            }

            function revert_error_42b3090547df1d2001c96683413b8cf91c1b902ef5e3cb8d9f6f304cf7446f74() {
                revert(0, 0)
            }

            /// @ast-id 19
            /// @src 0:126:212  "function test1(uint256[] memory amounts) external {..."
            function fun_test1_19(var_amounts_11_mpos) {

                /// @src 0:197:204  "amounts"
                let _1_mpos := var_amounts_11_mpos
                let expr_15_mpos := _1_mpos
                fun_iacceptmem_8(expr_15_mpos)

            }
            /// @src 0:34:309  "contract Dummy {..."

            /// @ast-id 8
            /// @src 0:55:117  "function iacceptmem(uint256[] memory amounts) internal {..."
            function fun_iacceptmem_8(var_amounts_4_mpos) {

            }
            /// @src 0:34:309  "contract Dummy {..."

            function convert_array_t_array$_t_uint256_$dyn_calldata_ptr_to_t_array$_t_uint256_$dyn_memory_ptr(value, length) -> converted  {

                // Copy the array to a free position in memory
                converted :=

                abi_decode_available_length_t_array$_t_uint256_$dyn_memory_ptr(value, length, calldatasize())

            }

            /// @ast-id 30
            /// @src 0:218:306  "function test2(uint256[] calldata amounts) external {..."
            function fun_test2_30(var_amounts_22_offset, var_amounts_22_length) {

                /// @src 0:291:298  "amounts"
                let _2_offset := var_amounts_22_offset
                let _2_length := var_amounts_22_length
                let expr_26_offset := _2_offset
                let expr_26_length := _2_length
                /// @src 0:280:299  "iacceptmem(amounts)"
                let _3_mpos := convert_array_t_array$_t_uint256_$dyn_calldata_ptr_to_t_array$_t_uint256_$dyn_memory_ptr(expr_26_offset, expr_26_length)
                fun_iacceptmem_8(_3_mpos)

            }
            /// @src 0:34:309  "contract Dummy {..."

        }

        data ".metadata" hex"a264697066735822122091a53881f8929bec21fa931e3080f22f8cb7c482302a60077aa702ca84fa110e64736f6c63430008140033"
    }

}


IR:

/// @use-src 0:"test.sol"
object "Tester_81" {
    code {
        /// @src 0:312:598  "contract Tester {..."
        mstore(64, memoryguard(128))
        if callvalue() { revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb() }

        constructor_Tester_81()

        let _1 := allocate_unbounded()
        codecopy(_1, dataoffset("Tester_81_deployed"), datasize("Tester_81_deployed"))

        return(_1, datasize("Tester_81_deployed"))

        function allocate_unbounded() -> memPtr {
            memPtr := mload(64)
        }

        function revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb() {
            revert(0, 0)
        }

        function panic_error_0x41() {
            mstore(0, 35408467139433450592217433187231851964531694900788300625387963629091585785856)
            mstore(4, 0x41)
            revert(0, 0x24)
        }

        function abi_encode_tuple__to__fromStack(headStart ) -> tail {
            tail := add(headStart, 0)

        }

        function revert_forward_1() {
            let pos := allocate_unbounded()
            returndatacopy(pos, 0, returndatasize())
            revert(pos, returndatasize())
        }

        function shift_left_0(value) -> newValue {
            newValue :=

            shl(0, value)

        }

        function update_byte_slice_20_shift_0(value, toInsert) -> result {
            let mask := 0xffffffffffffffffffffffffffffffffffffffff
            toInsert := shift_left_0(toInsert)
            value := and(value, not(mask))
            result := or(value, and(toInsert, mask))
        }

        function cleanup_t_uint160(value) -> cleaned {
            cleaned := and(value, 0xffffffffffffffffffffffffffffffffffffffff)
        }

        function identity(value) -> ret {
            ret := value
        }

        function convert_t_uint160_to_t_uint160(value) -> converted {
            converted := cleanup_t_uint160(identity(cleanup_t_uint160(value)))
        }

        function convert_t_uint160_to_t_contract$_Dummy_$31(value) -> converted {
            converted := convert_t_uint160_to_t_uint160(value)
        }

        function convert_t_contract$_Dummy_$31_to_t_contract$_Dummy_$31(value) -> converted {
            converted := convert_t_uint160_to_t_contract$_Dummy_$31(value)
        }

        function prepare_store_t_contract$_Dummy_$31(value) -> ret {
            ret := value
        }

        function update_storage_value_offset_0t_contract$_Dummy_$31_to_t_contract$_Dummy_$31(slot, value_0) {
            let convertedValue_0 := convert_t_contract$_Dummy_$31_to_t_contract$_Dummy_$31(value_0)
            sstore(slot, update_byte_slice_20_shift_0(sload(slot), prepare_store_t_contract$_Dummy_$31(convertedValue_0)))
        }

        /// @src 0:312:598  "contract Tester {..."
        function constructor_Tester_81() {

            /// @src 0:312:598  "contract Tester {..."

            /// @src 0:344:355  "new Dummy()"
            let _2 := allocate_unbounded()
            let _3 := add(_2, datasize("Dummy_31"))
            if or(gt(_3, 0xffffffffffffffff), lt(_3, _2)) { panic_error_0x41() }
            datacopy(_2, dataoffset("Dummy_31"), datasize("Dummy_31"))
            _3 := abi_encode_tuple__to__fromStack(_3)

            let expr_37_address := create(0, _2, sub(_3, _2))

            if iszero(expr_37_address) { revert_forward_1() }

            update_storage_value_offset_0t_contract$_Dummy_$31_to_t_contract$_Dummy_$31(0x00, expr_37_address)

        }
        /// @src 0:312:598  "contract Tester {..."

    }
    /// @use-src 0:"test.sol"
    object "Tester_81_deployed" {
        code {
            /// @src 0:312:598  "contract Tester {..."
            mstore(64, memoryguard(128))

            if iszero(lt(calldatasize(), 4))
            {
                let selector := shift_right_224_unsigned(calldataload(0))
                switch selector

                case 0x5b364e45
                {
                    // call_test1()

                    external_fun_call_test1_59()
                }

                case 0xe948a22b
                {
                    // call_test2()

                    external_fun_call_test2_80()
                }

                default {}
            }

            revert_error_42b3090547df1d2001c96683413b8cf91c1b902ef5e3cb8d9f6f304cf7446f74()

            function shift_right_224_unsigned(value) -> newValue {
                newValue :=

                shr(224, value)

            }

            function allocate_unbounded() -> memPtr {
                memPtr := mload(64)
            }

            function revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb() {
                revert(0, 0)
            }

            function revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b() {
                revert(0, 0)
            }

            function abi_decode_tuple_(headStart, dataEnd)   {
                if slt(sub(dataEnd, headStart), 0) { revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b() }

            }

            function abi_encode_tuple__to__fromStack(headStart ) -> tail {
                tail := add(headStart, 0)

            }

            function external_fun_call_test1_59() {

                if callvalue() { revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb() }
                abi_decode_tuple_(4, calldatasize())
                fun_call_test1_59()
                let memPos := allocate_unbounded()
                let memEnd := abi_encode_tuple__to__fromStack(memPos  )
                return(memPos, sub(memEnd, memPos))

            }

            function external_fun_call_test2_80() {

                if callvalue() { revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb() }
                abi_decode_tuple_(4, calldatasize())
                fun_call_test2_80()
                let memPos := allocate_unbounded()
                let memEnd := abi_encode_tuple__to__fromStack(memPos  )
                return(memPos, sub(memEnd, memPos))

            }

            function revert_error_42b3090547df1d2001c96683413b8cf91c1b902ef5e3cb8d9f6f304cf7446f74() {
                revert(0, 0)
            }

            function cleanup_t_rational_1000_by_1(value) -> cleaned {
                cleaned := value
            }

            function cleanup_t_uint256(value) -> cleaned {
                cleaned := value
            }

            function identity(value) -> ret {
                ret := value
            }

            function convert_t_rational_1000_by_1_to_t_uint256(value) -> converted {
                converted := cleanup_t_uint256(identity(cleanup_t_rational_1000_by_1(value)))
            }

            function round_up_to_mul_of_32(value) -> result {
                result := and(add(value, 31), not(31))
            }

            function panic_error_0x41() {
                mstore(0, 35408467139433450592217433187231851964531694900788300625387963629091585785856)
                mstore(4, 0x41)
                revert(0, 0x24)
            }

            function finalize_allocation(memPtr, size) {
                let newFreePtr := add(memPtr, round_up_to_mul_of_32(size))
                // protect against overflow
                if or(gt(newFreePtr, 0xffffffffffffffff), lt(newFreePtr, memPtr)) { panic_error_0x41() }
                mstore(64, newFreePtr)
            }

            function allocate_memory(size) -> memPtr {
                memPtr := allocate_unbounded()
                finalize_allocation(memPtr, size)
            }

            function array_allocation_size_t_array$_t_uint256_$dyn_memory_ptr(length) -> size {
                // Make sure we can allocate memory without overflow
                if gt(length, 0xffffffffffffffff) { panic_error_0x41() }

                size := mul(length, 0x20)

                // add length slot
                size := add(size, 0x20)

            }

            function allocate_memory_array_t_array$_t_uint256_$dyn_memory_ptr(length) -> memPtr {
                let allocSize := array_allocation_size_t_array$_t_uint256_$dyn_memory_ptr(length)
                memPtr := allocate_memory(allocSize)

                mstore(memPtr, length)

            }

            function zero_memory_chunk_t_uint256(dataStart, dataSizeInBytes) {
                calldatacopy(dataStart, calldatasize(), dataSizeInBytes)
            }

            function allocate_and_zero_memory_array_t_array$_t_uint256_$dyn_memory_ptr(length) -> memPtr {
                memPtr := allocate_memory_array_t_array$_t_uint256_$dyn_memory_ptr(length)
                let dataStart := memPtr
                let dataSize := array_allocation_size_t_array$_t_uint256_$dyn_memory_ptr(length)

                dataStart := add(dataStart, 32)
                dataSize := sub(dataSize, 32)

                zero_memory_chunk_t_uint256(dataStart, dataSize)
            }

            function shift_right_0_unsigned(value) -> newValue {
                newValue :=

                shr(0, value)

            }

            function cleanup_from_storage_t_contract$_Dummy_$31(value) -> cleaned {
                cleaned := and(value, 0xffffffffffffffffffffffffffffffffffffffff)
            }

            function extract_from_storage_value_offset_0t_contract$_Dummy_$31(slot_value) -> value {
                value := cleanup_from_storage_t_contract$_Dummy_$31(shift_right_0_unsigned(slot_value))
            }

            function read_from_storage_split_offset_0_t_contract$_Dummy_$31(slot) -> value {
                value := extract_from_storage_value_offset_0t_contract$_Dummy_$31(sload(slot))

            }

            function cleanup_t_uint160(value) -> cleaned {
                cleaned := and(value, 0xffffffffffffffffffffffffffffffffffffffff)
            }

            function convert_t_uint160_to_t_uint160(value) -> converted {
                converted := cleanup_t_uint160(identity(cleanup_t_uint160(value)))
            }

            function convert_t_uint160_to_t_address(value) -> converted {
                converted := convert_t_uint160_to_t_uint160(value)
            }

            function convert_t_contract$_Dummy_$31_to_t_address(value) -> converted {
                converted := convert_t_uint160_to_t_address(value)
            }

            function revert_error_0cc013b6b3b6beabea4e3a74a6d380f0df81852ca99887912475e1f66b2a2c20() {
                revert(0, 0)
            }

            function shift_left_224(value) -> newValue {
                newValue :=

                shl(224, value)

            }

            function abi_decode_tuple__fromMemory(headStart, dataEnd)   {
                if slt(sub(dataEnd, headStart), 0) { revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b() }

            }

            function array_length_t_array$_t_uint256_$dyn_memory_ptr(value) -> length {

                length := mload(value)

            }

            function array_storeLengthForEncoding_t_array$_t_uint256_$dyn_memory_ptr_fromStack(pos, length) -> updated_pos {
                mstore(pos, length)
                updated_pos := add(pos, 0x20)
            }

            function array_dataslot_t_array$_t_uint256_$dyn_memory_ptr(ptr) -> data {
                data := ptr

                data := add(ptr, 0x20)

            }

            function abi_encode_t_uint256_to_t_uint256(value, pos) {
                mstore(pos, cleanup_t_uint256(value))
            }

            function abi_encodeUpdatedPos_t_uint256_to_t_uint256(value0, pos) -> updatedPos {
                abi_encode_t_uint256_to_t_uint256(value0, pos)
                updatedPos := add(pos, 0x20)
            }

            function array_nextElement_t_array$_t_uint256_$dyn_memory_ptr(ptr) -> next {
                next := add(ptr, 0x20)
            }

            // uint256[] -> uint256[]
            function abi_encode_t_array$_t_uint256_$dyn_memory_ptr_to_t_array$_t_uint256_$dyn_memory_ptr_fromStack(value, pos)  -> end  {
                let length := array_length_t_array$_t_uint256_$dyn_memory_ptr(value)
                pos := array_storeLengthForEncoding_t_array$_t_uint256_$dyn_memory_ptr_fromStack(pos, length)
                let baseRef := array_dataslot_t_array$_t_uint256_$dyn_memory_ptr(value)
                let srcPtr := baseRef
                for { let i := 0 } lt(i, length) { i := add(i, 1) }
                {
                    let elementValue0 := mload(srcPtr)
                    pos := abi_encodeUpdatedPos_t_uint256_to_t_uint256(elementValue0, pos)
                    srcPtr := array_nextElement_t_array$_t_uint256_$dyn_memory_ptr(srcPtr)
                }
                end := pos
            }

            function abi_encode_tuple_t_array$_t_uint256_$dyn_memory_ptr__to_t_array$_t_uint256_$dyn_memory_ptr__fromStack(headStart , value0) -> tail {
                tail := add(headStart, 32)

                mstore(add(headStart, 0), sub(tail, headStart))
                tail := abi_encode_t_array$_t_uint256_$dyn_memory_ptr_to_t_array$_t_uint256_$dyn_memory_ptr_fromStack(value0,  tail)

            }

            function revert_forward_1() {
                let pos := allocate_unbounded()
                returndatacopy(pos, 0, returndatasize())
                revert(pos, returndatasize())
            }

            /// @ast-id 59
            /// @src 0:362:476  "function call_test1() external {..."
            function fun_call_test1_59() {

                /// @src 0:441:445  "1000"
                let expr_49 := 0x03e8
                /// @src 0:427:446  "new uint256[](1000)"
                let _1 := convert_t_rational_1000_by_1_to_t_uint256(expr_49)
                let expr_50_mpos := allocate_and_zero_memory_array_t_array$_t_uint256_$dyn_memory_ptr(_1)
                /// @src 0:403:446  "uint256[] memory data = new uint256[](1000)"
                let var_data_45_mpos := expr_50_mpos
                /// @src 0:456:457  "d"
                let _2_address := read_from_storage_split_offset_0_t_contract$_Dummy_$31(0x00)
                let expr_52_address := _2_address
                /// @src 0:456:463  "d.test1"
                let expr_54_address := convert_t_contract$_Dummy_$31_to_t_address(expr_52_address)
                let expr_54_functionSelector := 0x6a3273b7
                /// @src 0:464:468  "data"
                let _3_mpos := var_data_45_mpos
                let expr_55_mpos := _3_mpos
                /// @src 0:456:469  "d.test1(data)"

                if iszero(extcodesize(expr_54_address)) { revert_error_0cc013b6b3b6beabea4e3a74a6d380f0df81852ca99887912475e1f66b2a2c20() }

                // storage for arguments and returned data
                let _4 := allocate_unbounded()
                mstore(_4, shift_left_224(expr_54_functionSelector))
                let _5 := abi_encode_tuple_t_array$_t_uint256_$dyn_memory_ptr__to_t_array$_t_uint256_$dyn_memory_ptr__fromStack(add(_4, 4) , expr_55_mpos)

                let _6 := call(gas(), expr_54_address,  0,  _4, sub(_5, _4), _4, 0)

                if iszero(_6) { revert_forward_1() }

                if _6 {

                    let _7 := 0

                    if gt(_7, returndatasize()) {
                        _7 := returndatasize()
                    }

                    // update freeMemoryPointer according to dynamic return size
                    finalize_allocation(_4, _7)

                    // decode return parameters from external try-call into retVars
                    abi_decode_tuple__fromMemory(_4, add(_4, _7))
                }

            }
            /// @src 0:312:598  "contract Tester {..."

            /// @ast-id 80
            /// @src 0:482:596  "function call_test2() external {..."
            function fun_call_test2_80() {

                /// @src 0:561:565  "1000"
                let expr_70 := 0x03e8
                /// @src 0:547:566  "new uint256[](1000)"
                let _8 := convert_t_rational_1000_by_1_to_t_uint256(expr_70)
                let expr_71_mpos := allocate_and_zero_memory_array_t_array$_t_uint256_$dyn_memory_ptr(_8)
                /// @src 0:523:566  "uint256[] memory data = new uint256[](1000)"
                let var_data_66_mpos := expr_71_mpos
                /// @src 0:576:577  "d"
                let _9_address := read_from_storage_split_offset_0_t_contract$_Dummy_$31(0x00)
                let expr_73_address := _9_address
                /// @src 0:576:583  "d.test2"
                let expr_75_address := convert_t_contract$_Dummy_$31_to_t_address(expr_73_address)
                let expr_75_functionSelector := 0x6f1f05ed
                /// @src 0:584:588  "data"
                let _10_mpos := var_data_66_mpos
                let expr_76_mpos := _10_mpos
                /// @src 0:576:589  "d.test2(data)"

                if iszero(extcodesize(expr_75_address)) { revert_error_0cc013b6b3b6beabea4e3a74a6d380f0df81852ca99887912475e1f66b2a2c20() }

                // storage for arguments and returned data
                let _11 := allocate_unbounded()
                mstore(_11, shift_left_224(expr_75_functionSelector))
                let _12 := abi_encode_tuple_t_array$_t_uint256_$dyn_memory_ptr__to_t_array$_t_uint256_$dyn_memory_ptr__fromStack(add(_11, 4) , expr_76_mpos)

                let _13 := call(gas(), expr_75_address,  0,  _11, sub(_12, _11), _11, 0)

                if iszero(_13) { revert_forward_1() }

                if _13 {

                    let _14 := 0

                    if gt(_14, returndatasize()) {
                        _14 := returndatasize()
                    }

                    // update freeMemoryPointer according to dynamic return size
                    finalize_allocation(_11, _14)

                    // decode return parameters from external try-call into retVars
                    abi_decode_tuple__fromMemory(_11, add(_11, _14))
                }

            }
            /// @src 0:312:598  "contract Tester {..."

        }

        data ".metadata" hex"a26469706673582212206b8eddd409c79e922dd0f0a51e1bc0de144b9cddce7abf43674cb1645c19260c64736f6c63430008140033"
    }

    /// @use-src 0:"test.sol"
    object "Dummy_31" {
        code {
            /// @src 0:34:309  "contract Dummy {..."
            mstore(64, memoryguard(128))
            if callvalue() { revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb() }

            constructor_Dummy_31()

            let _1 := allocate_unbounded()
            codecopy(_1, dataoffset("Dummy_31_deployed"), datasize("Dummy_31_deployed"))

            return(_1, datasize("Dummy_31_deployed"))

            function allocate_unbounded() -> memPtr {
                memPtr := mload(64)
            }

            function revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb() {
                revert(0, 0)
            }

            /// @src 0:34:309  "contract Dummy {..."
            function constructor_Dummy_31() {

                /// @src 0:34:309  "contract Dummy {..."

            }
            /// @src 0:34:309  "contract Dummy {..."

        }
        /// @use-src 0:"test.sol"
        object "Dummy_31_deployed" {
            code {
                /// @src 0:34:309  "contract Dummy {..."
                mstore(64, memoryguard(128))

                if iszero(lt(calldatasize(), 4))
                {
                    let selector := shift_right_224_unsigned(calldataload(0))
                    switch selector

                    case 0x6a3273b7
                    {
                        // test1(uint256[])

                        external_fun_test1_19()
                    }

                    case 0x6f1f05ed
                    {
                        // test2(uint256[])

                        external_fun_test2_30()
                    }

                    default {}
                }

                revert_error_42b3090547df1d2001c96683413b8cf91c1b902ef5e3cb8d9f6f304cf7446f74()

                function shift_right_224_unsigned(value) -> newValue {
                    newValue :=

                    shr(224, value)

                }

                function allocate_unbounded() -> memPtr {
                    memPtr := mload(64)
                }

                function revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb() {
                    revert(0, 0)
                }

                function revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b() {
                    revert(0, 0)
                }

                function revert_error_c1322bf8034eace5e0b5c7295db60986aa89aae5e0ea0873e4689e076861a5db() {
                    revert(0, 0)
                }

                function revert_error_1b9f4a0a5773e33b91aa01db23bf8c55fce1411167c872835e7fa00a4f17d46d() {
                    revert(0, 0)
                }

                function round_up_to_mul_of_32(value) -> result {
                    result := and(add(value, 31), not(31))
                }

                function panic_error_0x41() {
                    mstore(0, 35408467139433450592217433187231851964531694900788300625387963629091585785856)
                    mstore(4, 0x41)
                    revert(0, 0x24)
                }

                function finalize_allocation(memPtr, size) {
                    let newFreePtr := add(memPtr, round_up_to_mul_of_32(size))
                    // protect against overflow
                    if or(gt(newFreePtr, 0xffffffffffffffff), lt(newFreePtr, memPtr)) { panic_error_0x41() }
                    mstore(64, newFreePtr)
                }

                function allocate_memory(size) -> memPtr {
                    memPtr := allocate_unbounded()
                    finalize_allocation(memPtr, size)
                }

                function array_allocation_size_t_array$_t_uint256_$dyn_memory_ptr(length) -> size {
                    // Make sure we can allocate memory without overflow
                    if gt(length, 0xffffffffffffffff) { panic_error_0x41() }

                    size := mul(length, 0x20)

                    // add length slot
                    size := add(size, 0x20)

                }

                function revert_error_81385d8c0b31fffe14be1da910c8bd3a80be4cfa248e04f42ec0faea3132a8ef() {
                    revert(0, 0)
                }

                function cleanup_t_uint256(value) -> cleaned {
                    cleaned := value
                }

                function validator_revert_t_uint256(value) {
                    if iszero(eq(value, cleanup_t_uint256(value))) { revert(0, 0) }
                }

                function abi_decode_t_uint256(offset, end) -> value {
                    value := calldataload(offset)
                    validator_revert_t_uint256(value)
                }

                // uint256[]
                function abi_decode_available_length_t_array$_t_uint256_$dyn_memory_ptr(offset, length, end) -> array {
                    array := allocate_memory(array_allocation_size_t_array$_t_uint256_$dyn_memory_ptr(length))
                    let dst := array

                    mstore(array, length)
                    dst := add(array, 0x20)

                    let srcEnd := add(offset, mul(length, 0x20))
                    if gt(srcEnd, end) {
                        revert_error_81385d8c0b31fffe14be1da910c8bd3a80be4cfa248e04f42ec0faea3132a8ef()
                    }
                    for { let src := offset } lt(src, srcEnd) { src := add(src, 0x20) }
                    {

                        let elementPos := src

                        mstore(dst, abi_decode_t_uint256(elementPos, end))
                        dst := add(dst, 0x20)
                    }
                }

                // uint256[]
                function abi_decode_t_array$_t_uint256_$dyn_memory_ptr(offset, end) -> array {
                    if iszero(slt(add(offset, 0x1f), end)) { revert_error_1b9f4a0a5773e33b91aa01db23bf8c55fce1411167c872835e7fa00a4f17d46d() }
                    let length := calldataload(offset)
                    array := abi_decode_available_length_t_array$_t_uint256_$dyn_memory_ptr(add(offset, 0x20), length, end)
                }

                function abi_decode_tuple_t_array$_t_uint256_$dyn_memory_ptr(headStart, dataEnd) -> value0 {
                    if slt(sub(dataEnd, headStart), 32) { revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b() }

                    {

                        let offset := calldataload(add(headStart, 0))
                        if gt(offset, 0xffffffffffffffff) { revert_error_c1322bf8034eace5e0b5c7295db60986aa89aae5e0ea0873e4689e076861a5db() }

                        value0 := abi_decode_t_array$_t_uint256_$dyn_memory_ptr(add(headStart, offset), dataEnd)
                    }

                }

                function abi_encode_tuple__to__fromStack(headStart ) -> tail {
                    tail := add(headStart, 0)

                }

                function external_fun_test1_19() {

                    if callvalue() { revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb() }
                    let param_0 :=  abi_decode_tuple_t_array$_t_uint256_$dyn_memory_ptr(4, calldatasize())
                    fun_test1_19(param_0)
                    let memPos := allocate_unbounded()
                    let memEnd := abi_encode_tuple__to__fromStack(memPos  )
                    return(memPos, sub(memEnd, memPos))

                }

                function revert_error_15abf5612cd996bc235ba1e55a4a30ac60e6bb601ff7ba4ad3f179b6be8d0490() {
                    revert(0, 0)
                }

                // uint256[]
                function abi_decode_t_array$_t_uint256_$dyn_calldata_ptr(offset, end) -> arrayPos, length {
                    if iszero(slt(add(offset, 0x1f), end)) { revert_error_1b9f4a0a5773e33b91aa01db23bf8c55fce1411167c872835e7fa00a4f17d46d() }
                    length := calldataload(offset)
                    if gt(length, 0xffffffffffffffff) { revert_error_15abf5612cd996bc235ba1e55a4a30ac60e6bb601ff7ba4ad3f179b6be8d0490() }
                    arrayPos := add(offset, 0x20)
                    if gt(add(arrayPos, mul(length, 0x20)), end) { revert_error_81385d8c0b31fffe14be1da910c8bd3a80be4cfa248e04f42ec0faea3132a8ef() }
                }

                function abi_decode_tuple_t_array$_t_uint256_$dyn_calldata_ptr(headStart, dataEnd) -> value0, value1 {
                    if slt(sub(dataEnd, headStart), 32) { revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b() }

                    {

                        let offset := calldataload(add(headStart, 0))
                        if gt(offset, 0xffffffffffffffff) { revert_error_c1322bf8034eace5e0b5c7295db60986aa89aae5e0ea0873e4689e076861a5db() }

                        value0, value1 := abi_decode_t_array$_t_uint256_$dyn_calldata_ptr(add(headStart, offset), dataEnd)
                    }

                }

                function external_fun_test2_30() {

                    if callvalue() { revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb() }
                    let param_0, param_1 :=  abi_decode_tuple_t_array$_t_uint256_$dyn_calldata_ptr(4, calldatasize())
                    fun_test2_30(param_0, param_1)
                    let memPos := allocate_unbounded()
                    let memEnd := abi_encode_tuple__to__fromStack(memPos  )
                    return(memPos, sub(memEnd, memPos))

                }

                function revert_error_42b3090547df1d2001c96683413b8cf91c1b902ef5e3cb8d9f6f304cf7446f74() {
                    revert(0, 0)
                }

                /// @ast-id 19
                /// @src 0:126:212  "function test1(uint256[] memory amounts) external {..."
                function fun_test1_19(var_amounts_11_mpos) {

                    /// @src 0:197:204  "amounts"
                    let _1_mpos := var_amounts_11_mpos
                    let expr_15_mpos := _1_mpos
                    fun_iacceptmem_8(expr_15_mpos)

                }
                /// @src 0:34:309  "contract Dummy {..."

                /// @ast-id 8
                /// @src 0:55:117  "function iacceptmem(uint256[] memory amounts) internal {..."
                function fun_iacceptmem_8(var_amounts_4_mpos) {

                }
                /// @src 0:34:309  "contract Dummy {..."

                function convert_array_t_array$_t_uint256_$dyn_calldata_ptr_to_t_array$_t_uint256_$dyn_memory_ptr(value, length) -> converted  {

                    // Copy the array to a free position in memory
                    converted :=

                    abi_decode_available_length_t_array$_t_uint256_$dyn_memory_ptr(value, length, calldatasize())

                }

                /// @ast-id 30
                /// @src 0:218:306  "function test2(uint256[] calldata amounts) external {..."
                function fun_test2_30(var_amounts_22_offset, var_amounts_22_length) {

                    /// @src 0:291:298  "amounts"
                    let _2_offset := var_amounts_22_offset
                    let _2_length := var_amounts_22_length
                    let expr_26_offset := _2_offset
                    let expr_26_length := _2_length
                    /// @src 0:280:299  "iacceptmem(amounts)"
                    let _3_mpos := convert_array_t_array$_t_uint256_$dyn_calldata_ptr_to_t_array$_t_uint256_$dyn_memory_ptr(expr_26_offset, expr_26_length)
                    fun_iacceptmem_8(_3_mpos)

                }
                /// @src 0:34:309  "contract Dummy {..."

            }

            data ".metadata" hex"a264697066735822122091a53881f8929bec21fa931e3080f22f8cb7c482302a60077aa702ca84fa110e64736f6c63430008140033"
        }

    }

}
```

#### <img src="https://avatars.githubusercontent.com/u/457348?u=e02c93e6d98c1154952140a8d5af50d9d5ca59c9&v=4" width="50">[r0qs](https://github.com/r0qs) commented at [2023-07-26 13:30](https://github.com/ethereum/solidity/issues/14444#issuecomment-1651813780):

> Hi there, thanks for replying! However, I am not sure I fully understand the point here. I believe they should have similar gas consumption because they both convert from `calldata` to `memory` once. The only difference is the happening order. From yul file, it also proves that the most heavy function `abi_decode_available_length_t_array$_t_uint256_$dyn_memory_ptr` is called:
> 
>     1. For `Dummy.test1 `, it is called in the wrapper before actually calling `Dummy.test
> 
>     2. For `Dummy.test2`, it is called before calling `iacceptmem`
> 
> 
> In Remix IDE, the gas consumption for `Tester.call_test1` and `Tester.call_test2` is **552455** and **316317**. Not sure I understand correctly, it seems like you both think the second one should consume more. From yul file, they indeed have some small differences on CALLDATALOAD and other opcode, but that cannot explain the huge gas difference here. Would you elaborate more about why they have such huge gas consumption?

Hi @charlesxsh, are you using the legacy code generation pipeline or compiling via IR? I suspect that is the former, and if so, I would recommend that you switch to the [via IR pipeline](https://docs.soliditylang.org/en/v0.8.21/ir-breaking-changes.html).

If you compile your code using Solidity version `0.7.6+commit.7338295f`, the legacy codegen (i.e. the current default in remix) and `pragma experimental ABIEncoderV2;` it will result in similar gas consumption of the one you posted using Solidity version `0.8.+`, which corroborates what I mentioned before that the gas increase is probably due to the use of [ABIEncoderV2](https://docs.soliditylang.org/en/latest/080-breaking-changes.html#silent-changes-of-the-semantics) in legacy codegen. And this is because the `ABIEconderV2` is written in Yul and calling it from legacy code generation has an inherit overhead.

However, if you enable `viaIR` in the compiler settings you will get "similar" gas cost for both functions (e.g. around `268524`), but the second function will be slightly more expensive due to the validations that I mentioned previously. Regardless, you should keep in mind that they are not supposed to have equal gas costs and that it is recommended to use the via IR pipeline whenever possible since it will eventually become the default.

#### <img src="https://avatars.githubusercontent.com/u/8362565?u=c59e95752146dd37ad7d06d0558283ed877eb546&v=4" width="50">[charlesxsh](https://github.com/charlesxsh) commented at [2023-07-26 15:39](https://github.com/ethereum/solidity/issues/14444#issuecomment-1652069961):

Hi @r0qs , thanks for such detail response. Indeed I used the legacy code generation pipeline. And I tried enabling `viaIR` and both functions achieved the similar gas cost! That is amazing. The only question I left is the root cause for why legacy codegen + ABIEncoderV2 will make a huge gas difference for these two functions. Would you point out where is the related code for handling calldata -> memory conversion at the function parameter and at the function body in the compiler?


-------------------------------------------------------------------------------



[Export of Github issue for [ethereum/solidity](https://github.com/ethereum/solidity). Generated on 2024.12.15 at 06:45:24.]
