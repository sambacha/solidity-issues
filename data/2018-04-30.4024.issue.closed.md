# [\#4024 Issue](https://github.com/ethereum/solidity/issues/4024) `closed`: Compile time evaluation of constant hashes
**Labels**: `feature`


#### <img src="https://avatars.githubusercontent.com/u/20796281?u=3ade059256c951779e598bb585d7d85463f340a3&v=4" width="50">[benjaminion](https://github.com/benjaminion) opened issue at [2018-04-30 14:28](https://github.com/ethereum/solidity/issues/4024):

There's room for improvement in optimising compile-time evaluation of constant hashes when optimisation is enabled.

```
contract Hash{

    bytes32 constant HASH1 = keccak256('');
    bytes32 constant HASH2 = keccak256('12345678901234567890123456789012');
    bytes32 constant HASH3 = keccak256(uint256(0));
    
    function foo1() public pure returns (bytes32) {
        return HASH1;
    }

    function foo2() public pure returns (bytes32) {
        return HASH2;
    }

    function foo3() public pure returns (bytes32) {
        return HASH3;
    }
}
```

With optimisation off, none of the constant hashes is evaluated at compile-time. In each case the `keccak256` operation is being done at run time. This is somewhat expected.

With optimisation enabled, only the first (`keccak256('')`) is evaluated at compile time. The remainder (`keccak256('12345678901234567890123456789012')`, `keccak256(uint256(0))`) are evaluated at run time, as if optimisation were off. This is unexpected. Expected behaviour would be to evaluate all constant hashes at compile time.

Test environment: Remix, Solidity version 0.4.23+commit.124ca40d
Conclusions reached by inspecting the generated byte code. It's quite obvious if the hash is present or not.


#### <img src="https://avatars.githubusercontent.com/u/9073706?v=4" width="50">[chriseth](https://github.com/chriseth) commented at [2018-04-30 14:28](https://github.com/ethereum/solidity/issues/4024#issuecomment-385423878):

This has to do with the trade-off between code deployment costs and runtime costs. There is a setting in the optimizer called "runs" where you can adjust it.

#### <img src="https://avatars.githubusercontent.com/u/9073706?v=4" width="50">[chriseth](https://github.com/chriseth) commented at [2018-04-30 14:28](https://github.com/ethereum/solidity/issues/4024#issuecomment-385424356):

Note that storing a single byte in code costs at least 200+68 gas.

#### <img src="https://avatars.githubusercontent.com/u/20796281?u=3ade059256c951779e598bb585d7d85463f340a3&v=4" width="50">[benjaminion](https://github.com/benjaminion) commented at [2018-04-30 14:28](https://github.com/ethereum/solidity/issues/4024#issuecomment-385424853):

I understand this, which is why the second example (`keccak256('12345678901234567890123456789012')`) is constructed so that it is *always* cheaper to embed the hash in the deployment code, irrespective of the runs parameter.

This also does not explain why `keccak256('')` is compile-time executed when optimised, but the others are not. Your explanation would suggest the opposite should be true.

#### <img src="https://avatars.githubusercontent.com/u/9073706?v=4" width="50">[chriseth](https://github.com/chriseth) commented at [2018-04-30 14:28](https://github.com/ethereum/solidity/issues/4024#issuecomment-385426806):

OK, perhaps this is not at all related to the compiler finding the most efficient way, but rather to the fact that the value of `keccak256('')` does not depend on the state of memory when calculating the hash.

#### <img src="https://avatars.githubusercontent.com/u/9073706?v=4" width="50">[chriseth](https://github.com/chriseth) commented at [2018-04-30 14:28](https://github.com/ethereum/solidity/issues/4024#issuecomment-385428453):

A place to start would be to check if the check just after `// If all arguments are known constants, compute the Keccak-256 here` in KnownState.cpp turns out to be true for non-empty keccak256 calls.

#### <img src="https://avatars.githubusercontent.com/u/20796281?u=3ade059256c951779e598bb585d7d85463f340a3&v=4" width="50">[benjaminion](https://github.com/benjaminion) commented at [2018-04-30 14:28](https://github.com/ethereum/solidity/issues/4024#issuecomment-385626602):

Considering the two test cases, `keccak256('12345678901234567890123456789012')` and `keccak256(uint256(0))`.

> A place to start would be to check if the check just after `// If all arguments are known constants, compute the Keccak-256 here` in KnownState.cpp turns out to be true for non-empty keccak256 calls.

In both these cases, execution does not reach that line (although it does and is correctly handled for the empty hash).

In both of the test cases, `applyKeccak256()` is called three times (which is a surprise - it is called only once for the empty hash).

Each time, `applyKeccak256()` exits at the check `if (!l || *l > 128)` since `!l` is true at this point. That is, `m_expressionClasses->knownConstant(_length)` is (incorrectly?) returning a `false` value each time for these hash operands.

This is as far as my ability to debug C++ can take me...

Setup:
```
> solc/solc --version
solc, the solidity compiler commandline interface
Version: 0.4.24-develop.2018.5.1+commit.5cce2e55.mod.Linux.g++

> solc/solc --optimize const-keccak.sol
```

#### <img src="https://avatars.githubusercontent.com/u/9073706?v=4" width="50">[chriseth](https://github.com/chriseth) commented at [2018-04-30 14:28](https://github.com/ethereum/solidity/issues/4024#issuecomment-386015387):

OK, I will take a look later this week!

#### <img src="https://avatars.githubusercontent.com/u/20340?v=4" width="50">[axic](https://github.com/axic) commented at [2018-04-30 14:28](https://github.com/ethereum/solidity/issues/4024#issuecomment-458779983):

@chriseth have you checked this by any chance?

#### <img src="https://avatars.githubusercontent.com/u/9073706?v=4" width="50">[chriseth](https://github.com/chriseth) commented at [2018-04-30 14:28](https://github.com/ethereum/solidity/issues/4024#issuecomment-458867832):

No, sorry.

#### <img src="https://avatars.githubusercontent.com/u/2530770?u=a2b81f85d207864b7db06415db53010c21633b33&v=4" width="50">[nventuro](https://github.com/nventuro) commented at [2018-04-30 14:28](https://github.com/ethereum/solidity/issues/4024#issuecomment-579903133):

Are there plans to improve this in the near future? From @chriseth's description above it sounds like the tools to achieve this are already present, just not being used in all scenarios.

I find myself recommending people to use hard-coded `bytes32` constants to save gas, instead of having the `keccak256` call in the source code. This is far from ideal: computing said hash outside of Solidity is annoying, and having a 66-character constant is error-prone, specially in situations where a value _must_ be the result of a hash for security reasons. This also comes in while auditing, since readers must verify manually that the constant matches the expected value.

#### <img src="https://avatars.githubusercontent.com/u/9073706?v=4" width="50">[chriseth](https://github.com/chriseth) commented at [2018-04-30 14:28](https://github.com/ethereum/solidity/issues/4024#issuecomment-579986618):

The problem is that 1) it is dangerous to re-implement this outside of the EVM and 2) it is not clear how we should handle memory objects at compile-time.

Concerning hashes: The optimizer should actually remove the keccak256 opcode. It might not do it because it is cheaper depending on the "runs" setting (a 32 byte constant is rather expensive to deploy).

#### <img src="https://avatars.githubusercontent.com/u/20340?v=4" width="50">[axic](https://github.com/axic) commented at [2018-04-30 14:28](https://github.com/ethereum/solidity/issues/4024#issuecomment-645376127):

Could we make one exception and evaluate `keccak256(string)`? That is used in quite a few contracts.

#### <img src="https://avatars.githubusercontent.com/u/9073706?v=4" width="50">[chriseth](https://github.com/chriseth) commented at [2018-04-30 14:28](https://github.com/ethereum/solidity/issues/4024#issuecomment-645377855):

This could be a good exception. I would propose to put the value in the annotation object of the constant as opposed to fully supporting this in the type system as we do for constants.

#### <img src="https://avatars.githubusercontent.com/u/1661138?u=8b89adb541c393ba7b92e58fc119aa71b3a357ee&v=4" width="50">[dmihal](https://github.com/dmihal) commented at [2018-04-30 14:28](https://github.com/ethereum/solidity/issues/4024#issuecomment-680745451):

Do creationCode hashes get compile-time-hashed as well? Such as this:

    bytes32 public constant CONTRACT_BYTECODE_HASH = keccak256(type(MyContract).creationCode);

These hashes are useful for optimizing Create2 calculation

#### <img src="https://avatars.githubusercontent.com/u/9073706?v=4" width="50">[chriseth](https://github.com/chriseth) commented at [2018-04-30 14:28](https://github.com/ethereum/solidity/issues/4024#issuecomment-681025288):

I don't think this is optimized. There is a proposal to add a function to `type(MyContract)` instead to directly retrieve the create2 address given a salt.

#### <img src="https://avatars.githubusercontent.com/u/20340?v=4" width="50">[axic](https://github.com/axic) commented at [2018-04-30 14:28](https://github.com/ethereum/solidity/issues/4024#issuecomment-683113664):

> There is a proposal to add a function to type(MyContract) instead to directly retrieve the create2 address given a salt.

It is covered in #8798.


-------------------------------------------------------------------------------



[Export of Github issue for [ethereum/solidity](https://github.com/ethereum/solidity). Generated on 2022.05.23 at 03:51:38.]
