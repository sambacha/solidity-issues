# [\#11718 Issue](https://github.com/ethereum/solidity/issues/11718) `open`: Allow functions inside structs
**Labels**: `enhancement`, `feature`, `language design :rage4:`


#### <img src="https://avatars.githubusercontent.com/u/382183?u=cc7b2e76c56456ff05e23fa5ca044e4a461b2eb1&v=4" width="50">[fulldecent](https://github.com/fulldecent) opened issue at [2021-07-28 18:47](https://github.com/ethereum/solidity/issues/11718):

## Abstract

Putting functions and private members inside a struct creates first-class data structures.

## Motivation

People want data structures. There are many inconsistent ways to do this. And they are not semantic. A struct with functions is semantic, everybody understands what it is, and clearly articulates what you are doing.

Currently people use [something like](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/f7da53cebd41b6d3371d009b57beccc8f999ccfd/contracts/mocks/BitmapMock.sol):

```solidity
    using BitMaps for BitMaps.BitMap;

    BitMaps.BitMap private _bitmap;
```

This does not allow necessary encapsulation or access control on `_bitmap`.  You are directly able to touch the members inside which should be private.

## Specification

1. Allow definition of functions inside a struct, e.g. `struct Set {...}`.
2. Allow private members inside structs.
   3. These are not included in the initializer `new Set(...)`.
3. Allow a custom `initialize` function. This would cancel out the autogenerated `new Set(...)` function.
2. The functions can reference struct members as unqualified names, `this.` qualified names, and as `Set.` qualified names.
3. Struct functions cannot be called statically (`Set.someFunction()`).
4. The only way to call the functions is on the variable like `someSet.add(newElement)`.

Example:

```solidity
/**
 * @dev Library for managing uint256 to bool mapping in a compact and efficient way, providing the keys are sequential.
 */
struct BitMap {
    mapping(uint256 => uint256) private _data;

    /**
     * @dev Returns whether the bit at `index` is set.
     */
    function get(uint256 index) internal view returns (bool) {
        uint256 bucket = index / 256;
        uint256 mask = 1 << (index % 256);
        return _data[bucket] & mask != 0;
    }

    /**
     * @dev Sets the bit at `index` to the boolean `value`.
     */
    function setTo(
        uint256 index,
        bool value
    ) internal {
        if (value) {
            set(index);
        } else {
            unset(index);
        }
    }

    /**
     * @dev Sets the bit at `index`.
     */
    function set(uint256 index) internal {
        uint256 bucket = index / 256;
        uint256 mask = 1 << (index % 256);
        _data[bucket] |= mask;
    }

    /**
     * @dev Unsets the bit at `index`.
     */
    function unset(uint256 index) internal {
        uint256 bucket = index / 256;
        uint256 mask = 1 << (index % 256);
        _data[bucket] &= ~mask;
    }
}
```

Usage

```solidity
contract BitMapMock {
    Bitmap private _bitmap;

    function get(uint256 index) public view returns (bool) {
        return _bitmap.get(index);
    }

    function setTo(uint256 index, bool value) public {
        _bitmap.setTo(index, value);
    }

    function set(uint256 index) public {
        _bitmap.set(index);
    }

    function unset(uint256 index) public {
        _bitmap.unset(index);
    }
}
```

## Backwards Compatibility

None

## Notes

In the future we might consider static functions such as `Set.createRangeFromOneTo(5)`.

This greatly reduces the use case for Library.  

#### <img src="https://avatars.githubusercontent.com/u/13174375?u=52d702cb6bec53b561afa293cf9cd53ef7a63924&v=4" width="50">[hrkrshnn](https://github.com/hrkrshnn) commented at [2021-07-28 18:47](https://github.com/ethereum/solidity/issues/11718#issuecomment-890921392):

For functions inside structs, it's not clear what would be the storage location of the struct. Not sure if that's a good idea.

For example:

```
struct S {
   bool b;
   function set() internal {
     x = 1
   }
}
```

The above function on the struct is only valid for `memory` and `storage` and not `calldata`.

#### <img src="https://avatars.githubusercontent.com/u/9073706?v=4" width="50">[chriseth](https://github.com/chriseth) commented at [2021-07-28 18:47](https://github.com/ethereum/solidity/issues/11718#issuecomment-890929155):

We are currently going the route of declaring functions at file level and then attaching them to structs. The encapsulation aspect, though, could still be considered.


-------------------------------------------------------------------------------



[Export of Github issue for [ethereum/solidity](https://github.com/ethereum/solidity). Generated on 2022.05.23 at 03:51:38.]
